#! /usr/bin/env python
# ****************************************************************************
# Licensed to Qualys, Inc. (QUALYS) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# QUALYS licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ****************************************************************************
import re
import os
import sys
import shutil
import subprocess
import argparse
import time
import glob
import shlex
import tarfile
import git
import functools

from ib.util.version import *
from ib.util.version_reader import *
from ib.homevm.exceptions import *
from ib.homevm.build import *
from ib.homevm.config import *
from ib.homevm.parser import *

class DetectionError(BaseException) : pass

class _Parser( IbHomeVmParser ) :
    def __init__( self ) :
        IbHomeVmParser.__init__( self, "Program to create a build archive for VMs" )

        self.Parser.add_argument( "--ib-version",
                                  action="store", dest="ib_version", default=None,
                                  help="Specify IronBee version to use <auto>" )

        self.Parser.add_argument( "--ib-branch",
                                  action="store", dest="ib_branch", default=None,
                                  help="Specify alternate IronBee git branch name <auto>" )

        self.Parser.add_argument( "--etc-branch",
                                  action="store", dest="etc_branch", default=None,
                                  help="Specify alternate etc.in git branch name <auto>" )

        self.Parser.add_argument( "--gcc-version",
                                  action="store", dest="gcc_version", default=None,
                                  help="Specify GCC version to use <auto>" )

        self.Parser.add_argument( "--ats-version",
                                  action="store", dest="ats_version", default=None,
                                  help="Specify ATS version to use <auto>" )

        self.Parser.add_argument( "--ib-build-dir",
                                  action="store", dest="ib_build", default='.',
                                  help="Specify IronBee build directory <.>" )

        self.Parser.set_defaults( clean=False )
        self.Parser.add_argument( "--clean", "-c",
                                  action="store_true", dest="clean",
                                  help="Cleanup old archives <default=no>" )
        self.Parser.add_argument( "--no-clean",
                                  action="store_false", dest="clean",
                                  help="Disable cleanup of old archives" )

class _Main( object ) :
    def __init__( self ) :
        self._parser = _Parser( )

    def _ParseCmdline( self ) :
        self._args = self._parser.Parse()
        if self._args.timestamp is None :
            self._args.timestamp = time.time()

    def _ReadConfig( self ) :
        config = IbHomeVmConfig( self._args.config )
        self._config = config.Read( )

    def _ShowArchiveDir( self ) :
        print "Archive directory:", self._archive_dir
        if self.Execute :
            cmd = ( '/usr/bin/ls', '-lh', self._archive_dir )
            subprocess.call( cmd )
            print "Data:"
            with open( os.path.join(self._archive_dir, 'archives.txt') ) as fp :
                for line in fp :
                    print line.rstrip()

    def _ListArchives( self ) :
        cmd = ( '/usr/bin/ls', '-lh', self._archive_dir )
        subprocess.call( cmd )

    def _CleanArchives( self, verstring ) :
        timestamps = []
        archives = []
        for archive in glob.glob(self._ArchivePath('*', verstring, '*')) :
            m = regex.search( archive )
            assert m is not None
            if m.group(1) != self._args.timestamp :
                timestamps.append( m.group(1) )
        for timestamp in timestamps :
            for archive in glob.glob(self._ArchivePath('*', None, timestamp)) :
                archives.append(archive)
        if self.Verbose and len(archives):
            print "Cleaning archives:", archives
        if self.Execute :
            for archive in archives :
                os.remove( archive )

    def _DetectGccVersion( self ) :
        if self._args.gcc_version is not None :
            return self._args.gcc_version
        elif 'GCC_VERSION' in os.environ :
            return os.environ['GCC_VERSION']
        cmd = ( 'gcc', '--version' )
        output = subprocess.check_output( cmd )
        try :
            match = re.search( r' (\d+\.\d+)\.\d+', output )
            if match is None :
                raise DetectionError("Unable to detect gcc version!")
            return match.group(1)
        except OSError as e :
            raise DetectionError("Unable to detect gcc version:"+str(e))

    def _DetectAtsVersion( self ) :
        if self._args.ats_version is not None :
            return self._args.ats_version
        elif 'ATS_VERSION' in os.environ :
            return os.environ['ATS_VERSION']
        else :
            raise DetectionError("Unable to detect ATS version!")

    def _DetectIronBeeVersion( self ) :
        if self._args.ib_version is None :
            libdir = os.environ['IB_LIBDIR']
            path = IbVersionReader.FindFile( libdir )
            if path is None :
                raise DetectionError('Unable to find library file in "'+libdir+'"')
            vreader = IbVersionReader( )
            return vreader.GetAutoVersion( path )
        else :
            return IbVersion( self._args.ib_version )

    def _ReadBuildConfig( self ) :
        try :
            regex = re.compile(r'\s*\$\s+(.*)')
            for line in open(os.path.join(self._args.ib_build,'config.log') ) :
                match = regex.match(line)
                if match is not None :
                    return match.group(1)
        except IOError :
            pass
        return None

    def _DetectGitBranch( self, args_branch, repo_path ) :
        if args_branch is not None :
            return (args_branch, None)
        else :
            repo = git.Repo( repo_path )
            return (repo.active_branch.name, repo.commit().hexsha)

    def _DetectStuff( self ) :
        try :
            self._vm = IbHomeVmBuild( )
            self._vm.Architecture = self._args.arch
            self._vm.Bits = self._args.bits
            self._vm.GccVersion = self._DetectGccVersion( )
            self._vm.AtsVersion = self._DetectAtsVersion( )
            self._vm.IronBeeVersion = self._DetectIronBeeVersion( )
            self._vm.BuildConfig = self._ReadBuildConfig( )
            if self._vm.BuildConfig is not None :
                configure = shlex.split(self._vm.BuildConfig)[0]
                self._ib_root = os.path.dirname(configure)
            else :
                self._ib_root = os.environ['IB_ROOT']
            (self._vm.IronBeeGitBranch, self._vm.IronBeeGitCommit) = \
                self._DetectGitBranch( self._args.ib_branch, self._ib_root)
            (self._vm.EtcInGitBranch, self._vm.EtcInGitCommit) = \
                self._DetectGitBranch( self._args.etc_branch, os.environ['QLYS_ETC_IN'] )
            self._vm.TimeStamp = self._args.timestamp
            self._archive_dir = self._vm.GetPath( self._args.archives )
            self._ts_name = 'trafficserver-'+self._vm.AtsVersion
            if not self.Quiet :
                print 'Archives will be stored in "'+self._archive_dir
        except DetectionError as e:
            print >>sys.stderr, "Auto detection failed: ", e
            sys.exit(1)

    def _ArchiveFilter( self, patterns, tinfo ) :
        """
        Generic filter function for tarball archive creation using the tarball
        module.  This function takes a pointer to self, and a list / tuple of
        patterns, and a tarfile.TarInfo object.  The pattern list should
        should be a tuple/list with 2 elements: True/False, and a compiled re.
        When a path matches the pattern, the original tinfo will be returned
        if tf is True, otherwise None will be returned.  If, after exhausting
        all patterns, no match has been found, the original tinfo is returned.
        """
        for tf, regex in patterns :
            if regex.search( tinfo.name ) :
                if tf and self.Verbose :
                    print tinfo.name
                return tinfo if tf else None
        if self.Verbose >= 2 :
            print tinfo.name
        return tinfo

    def _CopyIgnore( self, patterns, basedir, names ) :
        """
        Generic filter function for filtering file name/paths based on patterns,
        matching the optional ignore parameter to shutil.copytree().  This
        function takes a pointer to self, and a list / tuple of patterns, a
        base directory, and a list of entries.  The pattern list should should
        be a tuple/list with 2 elements: True/False, and a compiled re.  When
        a path matches the pattern, the entry will be added to the ignore list
        if tf is True, otherwise it is excluded from the ignore list.  If,
        after exhausting all patterns, no match has been found, the entry is
        not added to the ignore list.  After completion, the final list of
        ignored names is returned.
        """
        ignore_list = []
        for name in names :
            path = os.path.join(basedir, name)
            ignore = None
            for (tf, regex) in patterns :
                if regex.search(path) :
                    ignore = tf
                    if self.Verbose >= 3 :
                        print path+':', ignore, regex.pattern
                    elif not ignore and self.Verbose >= 2 :
                        print path
                    break
            if ignore is True :
                ignore_list.append(name)
        return ignore_list

    def _CreateBuildArchive( self ) :
        tpath = os.path.join(self._archive_dir, 'build.tar.bz2')
        if not self.Quiet :
            print 'Creating build tarball', tpath
        tball = tarfile.TarFile.open( tpath, 'w:bz2' )
        os.chdir( self._args.build_root )
        tball.add( 'gcc',
                   filter=functools.partial(self._ArchiveFilter, []) )
        tball.add( os.environ.get('IB_BUILD','gcc-'+self._vm.GccVersion)+'/install',
                   filter=functools.partial(self._ArchiveFilter, []) )
        tball.close( )
        self._vm.AddArchive( 'build', 'build.tar.bz2', self._args.build_root )

    def _CreateLocalArchive( self ) :
        ignore_ats = self._ts_name.replace('.', '\.')
        ignore_rules = (
            # ignore?, pattern ..  First match wins
            (True,  re.compile(r'.*\.sock')),
            (True,  re.compile(r'tmp/.*')),
            (True,  re.compile(r'opt/'+ignore_ats+'/(etc|var|tmp)/*')),
            (False, re.compile(r'opt/'+ignore_ats+'/(bin|include|lib|share)')),
            (False, re.compile(r'opt/'+ignore_ats+'/?$')),
            (True,  re.compile(r'opt/(var|tmp|etc)/*')),
            (False, re.compile(r'opt/(var|tmp|etc)')),
            (True,  re.compile(r'opt/.*')),
            (True,  re.compile(r'etc/trafficserver/.*')),
            (True,  re.compile(r'etc/ironbee/.*')),
            (True,  re.compile(r'nginx')),
            (True,  re.compile(r'\.(log|blog|git|lock|meta|db|release)')),
            (True,  re.compile(r'log/(httpd|trafficserver/.*)')),
            (True,  re.compile(r'data')),
            (True,  re.compile(r'/core')),
            (True,  re.compile(r'ats.valgrind.*')),
            (True,  re.compile(r'crashes')),
        )

        tmpdir = os.path.join(os.environ['QLYS_TMP'], 'qualys')
        local = os.environ['QLYS_LOCAL']
        print 'Populating tmp local tree "'+tmpdir+'" from "'+local+'" ...'
        if self.Execute :
            if os.path.exists( tmpdir ) :
                shutil.rmtree( tmpdir )
            shutil.copytree( local, tmpdir,
                             ignore=functools.partial(self._CopyIgnore, ignore_rules) )
            dirs = (
                ('var', 'run'),
                ('var', 'log', 'trafficserver'),
                ('var', 'log', 'trafficserver'),
                ('var', 'trafficserver', 'log'),
                ('tmp',),
                ('bin',),
                ('share',),
            )
            for d in dirs :
                full = os.path.join(tmpdir, *d)
                if not os.path.exists( full ) :
                    os.makedirs( full )
            symlinks = ( 'etc', 'var', 'tmp' )
            for name in symlinks :
                os.symlink( os.path.join('../..', name),
                            os.path.join(tmpdir, 'opt', self._ts_name, name) )

        tpath = os.path.join(self._archive_dir, 'local.tar.bz2')
        if not self.Quiet :
            print 'Creating build tarball', tpath
        tball = tarfile.TarFile.open( tpath, 'w:bz2' )
        os.chdir( tmpdir )
        for d in ( 'bin', 'opt', 'share', 'tmp', 'var' ) :
            tball.add( d, filter=functools.partial(self._ArchiveFilter, []) )
        tball.close( )
        self._vm.AddArchive( 'local', 'local.tar.bz2', local )

    def _CreateEtcArchive( self ) :
        archive_rules = (
            (False, re.compile(r'trafficserver/release')),
            (False, re.compile(r'/trafficserver/')),
            (False, re.compile(r'/tmp')),
            (False, re.compile(r'/nginx')),
            (False, re.compile(r'/data')),
            (False, re.compile(r'\/\.git')),
            (False, re.compile(r'~$')),
        )
        tpath = os.path.join(self._archive_dir, 'etc.in.tar.bz2')
        if not self.Quiet :
            print 'Creating build tarball', tpath
        tball = tarfile.TarFile.open( tpath, 'w:bz2' )
        os.chdir( os.environ['QLYS_DEVEL'] )
        tball.add( 'etc.in',
                   filter=functools.partial(self._ArchiveFilter, archive_rules) )
        tball.close( )
        self._vm.AddArchive( 'etc-in', 'etc.in.tar.bz2', os.environ['QLYS_LOCAL'] )

    def _CreateSummary( self ) :
        self._vm.WriteArchiveData( self._args. )

    def _CreateArchives( self ) :
        self._archives = [ ]
        if self.Execute :
            os.makedirs( self._archive_dir )
        self._CreateBuildArchive( )
        self._CreateEtcArchive( )
        self._CreateLocalArchive( )
        self._CreateSummary( )

    Execute = property( lambda self : self._args.execute )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.quiet )

    def Main( self ) :
        self._ParseCmdline( )
        if self._args.list :
            self._ListArchives( )
            sys.exit( 0 )
        self._DetectStuff( )
        self._CreateArchives( )
        if self._args.clean :
            self._CleanArchives( verstring )
        if not self.Quiet :
            self._ShowArchiveDir( )

main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
