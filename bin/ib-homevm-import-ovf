#! /usr/bin/env python
###########################################################################
##
## Copyright(c) 2014 by Nick LeRoy, 310 Jones Ave, Fort Atkinson, WI
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
###########################################################################
import re
import os
import sys
import subprocess
import argparse
import platform
import glob

from ib.util.parser import *
from ib.util.version import *


class _Parser( IbBaseParser ) :
    def __init__( self, d ) :
        IbBaseParser.__init__( self,
                               "Program to import OVF images for IronBee on my home network",
                               formatter_class=argparse.RawDescriptionHelpFormatter,
                               epilog=\
'''
Examples:
   ib-homevm-import-ovf -v 0
   ib-homevm-import-ovf -v 1 0.3.2 --bits 32
   ib-homevm-import-ovf -q 2 0.3.4 --build
'''
)

        self.Parser.add_argument( "vm", type=int,
                                  help="# of VM to import into" )
        self.Parser.add_argument( "version", type=str, nargs='?',
                                  help="Version of image to import (default=latest)" )

        self.Parser.add_argument( "--arch", type=str, default=d['arch'],
                                  help="Specify alternate architecture <default={:s}>".format(d['arch']) )
        self.Parser.add_argument( "--os", type=str, default=d['os'],
                                  help="Specify alternate OS <default={:s}>".format(d['os']) )
        self.Parser.add_argument( "--bits", type=int, default=d['bits'],
                                  help="Specify alternate bits <default={:d}>".format(d['bits']) )
        self.Parser.add_argument( "--host", type=str, default=None,
                                  help="Specify alternate OS <default={:s}-vmnn>".format(d['host']) )
        self.Parser.add_argument( "--imagedir", default=None,
                                  help="Specify root image directory"+
                                  " <default=${IB_HOMEVM_IMAGES}/home-qualys{-build}-bits>" )

        self.Parser.add_argument( '--force-tar', action='store_true', default=False,
                                  help='Force running of tar, even if image directory exists' )

        self.Parser.add_argument( "--build", action="store_true", default=False,
                                   help="Instantiate a build image" )


class _ImageDir( object ) :
    def __init__( self, root, version ) :
        self._version = version
        self._imagedir = os.path.join( root, version )
        self._files = {}

    def Search( self ) :
        for name in os.listdir(self._imagedir) :
            full = os.path.join( self._imagedir, name )
            if '.tar.' in name  and  'tarball' not in self._files :
                self._files['tarball'] = full
            elif name.endswith( '-'+self._version )  and  os.path.isdir( full ) :
                for f in glob.glob( os.path.join(full,'*') ) :
                    ext = re.match(r'.*\.(\w+)', f).group(1)
                    if ext not in self._files :
                        self._files[ext] = os.path.join(full, f)
        return self._files
    Version  = property( lambda self : self._version )
    ImageDir = property( lambda self : self._imagedir )

    def __contains__( self, name ) :
        return name in self._files
    def __getitem__( self, name ) :
        return self._files.get( name )


class _Main( object ) :
    def __init__( self ) :
        self._defaults = {
            'arch' : platform.linux_distribution()[2],
            'os'   : '_'.join(platform.linux_distribution()[:2]).replace(' ', ''),
            'bits' : int(platform.architecture()[0].replace('bit', '')),
            'host' : platform.node(),
        }
        self._parser = _Parser( self._defaults )

    def _ParseCmdLine( self ) :
        self._args = self._parser.Parse( )
        if self._args.host is None :
            self._args.host = '{}-vm{:02d}'.format( platform.node(), self._args.vm )
        if self._args.bits != self._defaults['bits']  and  self._args.arch == self._defaults['arch'] :
            self._args.arch = 'x86_64' if self._args.bits == 64 else 'i686'
        elif self._args.bits == self._defaults['bits']  and  self._args.arch != self._defaults['arch'] :
            self._args.bits = 64 if self._args.arch == 'x86_64' else 32


    Version = property( lambda self : self._args.version )
    VM      = property( lambda self : self._args.vm )

    Arch    = property( lambda self : self._args.arch )
    OS      = property( lambda self : self._args.os )
    Bits    = property( lambda self : self._args.bits )
    Host    = property( lambda self : self._args.host )

    Execute = property( lambda self : self._args.execute )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.quiet )

    def _Import( self ) :
        vm_disk_root  = os.environ.get( 'IB_HOMEVM_ROOT', '/local/disks' )
        os_image_root = os.environ.get( 'IB_HOMEVM_IMAGES', '/home/qualys/os-images' )
        if not os.path.isdir(os_image_root) :
            print 'Image root directory "{}" does not exist'.format(os_image_root)

        # Detect version if required
        prefix1  = 'home-qualys{}-{}'.format('-build' if self._args.build else '', self.Bits)
        images = os.path.join( os_image_root, prefix1 )
        if self.Version is None :
            ver = None
            for d in os.listdir(images) :
                full = os.path.join(images, d)
                if not os.path.isdir( full ) :
                    print >>sys.stderr, 'Warning; ignoring non-directory "{}"'.format(full)
                    continue
                try :
                    iver = IbVersion( d )
                except IbVersionException :
                    print >>sys.stderr, 'Warning; ignoring invalid version "{}"'.format(full)
                    continue
                if ver is None or iver > ver :
                    ver = iver
            print 'Selected version {}'.format(ver)
            self._args.version = str(ver)

        imagedir = _ImageDir( images, self.Version )
        imagedir.Search( )
        if 'vmdk' not in imagedir or self._args.force_tar :
            if 'tarball' not in imagedir :
                print >>sys.stderr, 'No VM files or tarball in image directory "{}"'.format(imagedir)
                sys.exit(1)
            cmd = ( '/bin/tar', 'xvf', imagedir['tarball'] )
            print 'Extracting from "{}"'.format(imagedir['tarball'])
            if self.Execute :
                subprocess.call( cmd, cwd=imagedir.ImageDir )
                imagedir.Search( )
        inpath = imagedir['vmdk']
        outdir =  os.path.join( vm_disk_root, self.Host )
        if not os.path.isdir( outdir ) and self.Execute :
            os.makedirs( outdir )
        outpath = os.path.join( outdir, 'disk00.qcow2' )
        if self.Execute  and  not os.path.exists( inpath ) :
            self._parser.Error( 'Path for VMDK image "{}" does not exist'.format(inpath) )
        cmd = ('qemu-img', 'convert', '-O', 'qcow2', inpath, outpath )
        if self.Verbose :
            print "Executing:", cmd
        if self.Execute :
            subprocess.call( cmd )

    def Main( self ) :
        self._ParseCmdLine( )
        self._Import( )

main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
