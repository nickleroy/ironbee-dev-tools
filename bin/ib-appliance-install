#! /usr/bin/env python
###########################################################################
##
## Copyright(c) 2014 by Nick LeRoy, 310 Jones Ave, Fort Atkinson, WI
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
###########################################################################
import re
import os
import sys
import pwd
import glob
import subprocess
import argparse
import platform
import time
import shutil
import tarfile
import configobj
import stat

class _Parser( object ) :
    _parts = {
        'setup_homes' : {
            "arg"     : 'setup-homes',
            "default" : False,
            "help"    : "Setup root and user directories",
        },
        'setup_build' : {
            "arg"     : 'setup-build',
            "default" : False,
            "help"    : "Setup build tree",
        },
        'setup_swap' : {
            "arg"     : 'setup-swap',
            "default" : False,
            "help"    : "Setup swap space",
        },
        'extract' : {
            "arg"     : 'extract',
            "default" : True,
            "help"    : "Extract archives",
        },
    }

    def __init__( self ) :
        self._parser = argparse.ArgumentParser(
            description="Program to install IronBee on a VM host",
            prog="ib-appliance-install" )

        self._parser.add_argument( "--user",
                                   action="store", dest="user", default="nick",
                                   help='Specify user to setup <default:nick>' )

        default = "0.11"
        self._parser.add_argument( "ib_version", default=default,
                                   help="IronBee version to install <"+default+">" )

        arch = platform.linux_distribution()[2]
        self._parser.add_argument( "--arch",
                                   action="store", dest="arch", default=arch,
                                   help="Specify architector to use <"+arch+">" )
        self._parser.add_argument( "--timestamp",
                                   action="store", dest="timestamp", default=None,
                                   help='Specify timestamp of archives <default:None>' )
        self._parser.add_argument( "--branch",
                                   action="store", dest="branch", default=None,
                                   help="Specify git branch to use <None>" )

        class PartsAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                if option_string in ("--enable-all", "--init") :
                    only = False
                    value = True
                    arg = None
                elif option_string.endswith( "-only" ) :
                    only = True
                    value = True
                    arg = option_string[2:-5]
                elif option_string.startswith( "--no-" ) :
                    value = False
                    only = False
                    arg = option_string[5:]
                else :
                    value = True
                    only = False
                    arg = option_string[2:]

                for name,part in _Parser._parts.items( ) :
                    if arg is None  or  arg == part['arg'] :
                        vars(namespace)[name] = value
                        for other in _Parser._parts.keys() :
                            if other != name  and  only :
                                vars(namespace)[other] = False

        group = self._parser.add_argument_group( 'Mode', 'Enable for modes of operation' )
        for name,part in _Parser._parts.items( ) :
            arg = part['arg']
            default = part['default']
            help = part['help'] + ' <default=' + ('Yes' if default else 'No') + '>'
            group.add_argument( '--'+arg,
                                action=PartsAction, default=default, nargs=0,
                                help=help.capitalize() )
            group.add_argument( '--no-'+arg,
                                action=PartsAction, nargs=0,
                                help=('Do not '+help).capitalize() )
            group.add_argument( '--'+arg+'-only',
                                action=PartsAction, nargs=0,
                                help=('Only '+help).capitalize() )
        group.add_argument( '--enable-all', '--init',
                            action=PartsAction, nargs=0,
                            help='Enable all actions' )
        
        self._parser.add_argument( "--execute",
                                   action="store_true", dest="execute", default=True,
                                   help="Enable execution <default=yes>" )
        self._parser.add_argument( "-n", "--no-execute",
                                   action="store_false", dest="execute",
                                   help="Disable execution (for test/debug)" )
        self._parser.add_argument( "-v", "--verbose",
                                   action="count", dest="verbose", default=0,
                                   help="Increment verbosity level" )
        self._parser.add_argument( "-q", "--quiet",
                                   action="store_true", dest="quiet", default=False,
                                   help="be vewwy quiet (I'm hunting wabbits)" )

    def ParseCmdLine( self ) :
        self._args = self._parser.parse_args()
        if not self._args.execute  and  self._args.verbose == 0  and  not self._args.quiet :
            self._verbose = 1
        return self._args

class User( object ) :
    __cache = { }

    def __init__( self, user_name ) :
        self._user_name = user_name
        pwent = pwd.getpwnam(user_name)
        self._home = pwent.pw_dir
        self._uid = pwent.pw_uid
        self._gid = pwent.pw_gid

    def Chown( self, path ) :
        os.chown( path, self.Uid, self.Gid )

    def ChownDirs( self, group, paths ) :
        if group is None :
            group = self.Gid
        cmd = [ "/bin/chown", "-R", self._user_name+":"+str(group) ]
        cmd += list(paths)
        print "Executing", cmd
        subprocess.call( cmd )

    def ChownDir( self, group, path ) :
        self.ChownDirs( group, (path,) )

    def SetupHomeDir( self ) :
        if not os.path.exists( self.Home ) :
            os.makedirs( self.Home )

    def Finished( self ) :
        self.ChownDir( None, self._home )

    @classmethod
    def LookUp( cls, username ) :
        try :
            return cls.__cache[username]
        except KeyError :
            user = cls( username )
            cls.__cache[username] = user
            return user

    Name  = property( lambda self : self._user_name )
    Uid   = property( lambda self : self._uid )
    Gid   = property( lambda self : self._gid )
    Home  = property( lambda self : self._home )

class _Main( object ) :

    def __init__( self ) :
        self._parser = _Parser( )

    def _ParseCmdLine( self ) :
        self._args = self._parser.ParseCmdLine( )

    Execute = property( lambda self : self._args.execute )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.quiet )

    def _SearchFile( self, path, string ) :
        try :
            fp = open( path )
            for line in fp :
                if string in line :
                    return line
            else :
                return None
        except IOError :
            return None

    def _AppendFile( self, path, string ) :
        try :
            fp = open( path, "a" )
            print >>fp, string
            fp.close( )
        except IOError as e :
            print "Failed to append to file", path, ":", e

    def _SetupSwap( self ) :
        if self._SearchFile( "/proc/mounts", "/swap" ) :
            cmd = ( "/bin/umount", "/swap" )
            if self.Verbose : print cmd
            subprocess.call( cmd )
        if os.path.exists( '/swap' ) :
            os.rmdir( '/swap' )
        line = self._SearchFile( '/etc/fstab', '/swap' )
        if line is None :
            return
        cmd = ( 'sed', '-i', 's|/swap.*|swap swap defaults 0 0|', '/etc/fstab' )
        if self.Verbose : print cmd
        subprocess.call( cmd )
        cmd = ( 'mkswap', line.split(' ')[0] )
        if self.Verbose : print cmd
        subprocess.call( cmd )
        cmd = ( 'swapon', '-a' )
        if self.Verbose : print cmd
        subprocess.call( cmd )

    _template_dirs = {
        'home' : '/local',
        'root' : '/',
    }
    def _SetupHomes( self ) :
        for name, dest in self._template_dirs.items() :
            src = os.path.join( '/home/qualys/template', name )
            cmd = ( 'rsync', '-av', 'celeborn:'+src, dest )
            subprocess.call( cmd )

    def _SetupBuildDirs( self, user_name ) :
        # Create and mount /build
        print "Creating /build"
        for path in ( "/build", "/local/build" ) :
            if not os.path.exists( path ) :
                os.makedirs( path )
        if not self._SearchFile( "/etc/fstab", "/build" ) :
            self._AppendFile( "/etc/fstab", "/local/build       /build    none    bind    0 0" )
        if not self._SearchFile( "/proc/mounts", "/build" ) :
            cmd = [ "/bin/mount", "/build" ]
            subprocess.call( cmd )

    def _ArchivePath( self, name, name2, timestamp ) :
        ib = User.LookUp( "ironbee" )
        if name2 is None :
            archive_name = '%s-%s-%s.tar.gz' % ( name, self._args.arch, timestamp )
        else :
            archive_name = '%s-ib_%s-%s-%s.tar.gz' % ( name, name2, self._args.arch, timestamp )
        return os.path.join( ib.Home, 'data', archive_name )

    def _WipeDirs( self, dirpath, dirs ) :
        assert type(dirpath) == str
        assert type(dirs) in (list, tuple, set)
        for name in dirs :
            fullpath = os.path.join( dirpath, name )
            if os.path.exists( fullpath ) :
                for root, ldirs, lfiles in os.walk( fullpath ) :
                    for f in lfiles :
                        fp = os.path.join(root,f)
                        if os.path.islink( fp ) :
                            pass
                        elif not os.access( fp, os.W_OK ) :
                            os.chmod( fp, stat.S_IRUSR | stat.S_IWUSR )
                    for f in ldirs :
                        fp = os.path.join(root,f)
                        if os.path.islink( fp ) :
                            pass
                        elif not os.access( fp, os.W_OK ) :
                            os.chmod( fp, stat.S_IRWXU )
                shutil.rmtree( fullpath )

    def _PopulateDirectory( self, ib_version, timestamp, name, dirpath, user_name,
                            group=None, wipe=False ) :
        user = User.LookUp( user_name )
        if not os.path.exists( dirpath ) :
            os.makedirs( dirpath )
            user.ChownDir( "qualys", dirpath )
        tarball = self._ArchivePath( name, ib_version, timestamp )
        if not os.path.isfile( tarball ) :
            print >>sys.stderr, "Archive", tarball, "doesn not exist"
            sys.exit(1)
        try :
            print "Populating", dirpath, "from", tarball
            regex = re.compile( r'(\.?/)?([^\/]+)/' )
            tar = tarfile.open( tarball )
            top = set()
            for member in tar.getmembers() :
                if member.name.startswith("/") :
                    print >>sys.stderr, \
                        'Archive', fullpath, 'has fully qualified path! "%s"' % (member.name)
                    sys.exit(1)
                m = regex.match( member.name )
                if m is not None :
                    top.add( m.group(2) )
            if self.Execute :
                if wipe is None or wipe == False :
                    pass
                elif wipe == True :
                    self._WipeDirs( dirpath, top )
                elif type(wipe) in (list, tuple) :
                    self._WipeDirs( dirpath, wipe )
                else :
                    assert False, str(wipe)
                tar.extractall( path=dirpath )
                if os.geteuid() == 0 :
                    user.ChownDir( "qualys", dirpath )
            return [tarball]
        except tarfile.TarError as e :
            print >>sys.stderr, 'Error extracting from tarball "%s": %s' % ( tarball, e )
            sys.exit(1)

    def _ExtractTarballs( self, version, timestamp ) :
        tbs = []
        tbs += self._PopulateDirectory( version, timestamp,
                                        "build", "/build/qualys",
                                        self._args.user, "qualys",
                                        wipe=True )
        tbs += self._PopulateDirectory( None, timestamp,
                                        "local", "/local/qualys",
                                        self._args.user, "qualys",
                                        wipe=('opt', 'share', 'etc', 'etc.in') )
        tbs += self._PopulateDirectory( None, timestamp,
                                        "etc.in", "/local/qualys",
                                        self._args.user, "qualys", wipe=True )
        etc = "/local/qualys/etc"
        if os.path.exists( etc ) :
            shutil.rmtree( etc )
        os.makedirs( etc )
        path = os.path.join(etc, 'tarballs.txt')
        with open(path, 'w') as fp :
            for tb in tbs :
                print >>fp, tb

    def _SelectArchive( self ) :
        if self._args.branch is None :
            branch = None
            regex = re.compile( r'ib_([\d\.]+)-\w+-(\d{6}_\d{6})' )
        else :
            branch = self._args.branch.replace('-', '_').replace('/', '_')
            regex = re.compile( r'ib_([\d\.]+:\w+)-\w+-(\d{6}_\d{6})' )
        if self._args.timestamp is not None :
            return self._args.ib_version, self._args.timestamp

        if self._args.ib_version.count('.') == 1 :
            vpat = self._args.ib_version+'.*'
        elif self._args.ib_version.count('.') == 2 :
            vpat = self._args.ib_version
        else :
            print >>sys.stderr, 'Invalid version string "%s"' % ( self._args.ib_version )
        if self._args.branch is not None :
            vpat += ':'+branch

        latest = None
        timestr = None
        version = None
        for archive in glob.glob( self._ArchivePath('*', vpat, '*') ) :
            match = regex.search( archive )
            if match is None :
                continue
            timestamp = time.strptime( match.group(2), '%y%m%d_%H%M%S' )
            if latest is None  or  timestamp > latest :
                latest = timestamp
                version = match.group(1)
                timestr = match.group(2)
        if version is None :
            print >>sys.stderr, "No archives found!"
            sys.exit(1)
        return version,timestr

    def Main( self ) :
        self._ParseCmdLine( )
        if os.geteuid() != 0 :
            table = {
                'setup-homes' : self._args.setup_homes,
                'setup-build' : self._args.setup_build,
                'setup-swap' : self._args.setup_swap,
            }
            errors = []
            for n,v in table.items( ) :
                if v :
                    errors.append( n )
            if len(errors) :
                print >>sys.stderr, \
                    "This program needs to be run by root to perform selected operations:"
                for e in errors :
                    print >>sys.stderr, '\t'+e
                sys.exit( 1 )
        if self._args.setup_swap :
            self._SetupSwap( )
        if self._args.setup_homes :
            self._SetupHomes( )
        if self._args.setup_build :
            self._SetupBuildDirs( self._args.user )
        version, timestamp = self._SelectArchive( )
        if version is None or timestamp is None :
            if timestamp is None :
                print >>sys.stderr, "No archives matching IronBee", self._args.ib_version, "found"
            else :
                print >>sys.stderr, "No archives matching IronBee", \
                    self._args.ib_version, self._args.timestamp, "found"
            sys.exit( 1 )
        if self._args.extract :
            self._ExtractTarballs( version, timestamp )

main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
