#! /usr/bin/env python
###########################################################################
##
## Copyright(c) 2014 by Nick LeRoy, 310 Jones Ave, Fort Atkinson, WI
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
###########################################################################
import re
import os
import sys
import pwd
import glob
import subprocess
import argparse
import platform
import time

class _Parser( object ) :
    _parts = {
        'setup_homes' : {
            "arg"     : 'setup-homes',
            "default" : True,
            "help"    : "Setup root and user directories",
        },
        'setup_build' : {
            "arg"     : 'setup-build',
            "default" : True,
            "help"    : "Setup build tree",
        },
        'setup_swap' : {
            "arg"     : 'setup-swap',
            "default" : True,
            "help"    : "Setup swap space",
        },
        'extract' : {
            "arg"     : 'extract',
            "default" : True,
            "help"    : "Extract archives",
        },
    }

    def __init__( self ) :
        self._parser = argparse.ArgumentParser(
            description="Program to install IronBee on a VM host",
            prog="ib-appliance-install" )

        self._parser.add_argument( "--user",
                                   action="store", dest="user", default="nick",
                                   help='Specify user to setup <default:nick>' )

        default = "0.11"
        self._parser.add_argument( "ib_version", default=default,
                                   help="IronBee version to install <"+default+">" )

        arch = platform.linux_distribution()[2]
        self._parser.add_argument( "--arch",
                                   action="store", dest="arch", default=arch,
                                   help="Specify architector to use <"+arch+">" )
        self._parser.add_argument( "--timestamp",
                                   action="store", dest="timestamp", default=None,
                                   help='Specify timestamp of archives <default:None>' )

        self._parser.add_argument( "--branch",
                                   action="store", dest="arch", default=arch,
                                   help="Specify architector to use <"+arch+">" )
        class PartsAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                if option_string.startswith( "--only-" ) :
                    only = True
                    value = True
                    arg = option_string[7:]
                elif option_string.startswith( "--no-" ) :
                    value = False
                    only = False
                    arg = option_string[5:]
                else :
                    value = True
                    only = False
                    arg = option_string[2:]

                for name,part in _Parser._parts.items( ) :
                    if arg == part['arg'] :
                        vars(namespace)[name] = value
                        for other in _Parser._parts.keys() :
                            if other != name  and  only :
                                vars(namespace)[other] = False

        for name,part in _Parser._parts.items( ) :
            arg = part['arg']
            default = part['default']
            help = part['help'] + ' <default=' + ('Yes' if default else 'No') + '>'
            self._parser.add_argument( '--'+arg,
                                       action=PartsAction, dest=name, default=default, nargs=0,
                                       help=help.capitalize() )
            self._parser.add_argument( '--no-'+arg,
                                       action=PartsAction, dest=name, nargs=0,
                                       help=('Do not '+help).capitalize() )
            self._parser.add_argument( '--only-'+arg,
                                       action=PartsAction, dest=name, nargs=0,
                                       help=('Only '+help).capitalize() )
        
        self._parser.add_argument( "--execute",
                                   action="store_true", dest="execute", default=True,
                                   help="Enable execution <default=yes>" )
        self._parser.add_argument( "-n", "--no-execute",
                                   action="store_false", dest="execute",
                                   help="Disable execution (for test/debug)" )
        self._parser.add_argument( "-v", "--verbose",
                                   action="count", dest="verbose", default=0,
                                   help="Increment verbosity level" )
        self._parser.add_argument( "-q", "--quiet",
                                   action="store_true", dest="quiet", default=False,
                                   help="be vewwy quiet (I'm hunting wabbits)" )

    def ParseCmdLine( self ) :
        self._args = self._parser.parse_args()
        if not self._args.execute  and  self._args.verbose == 0  and  not self._args.quiet :
            self._verbose = 1
        return self._args

class User( object ) :
    __cache = { }

    def __init__( self, user_name ) :
        self._user_name = user_name
        pwent = pwd.getpwnam(user_name)
        self._home = pwent.pw_dir
        self._uid = pwent.pw_uid
        self._gid = pwent.pw_gid

    def Chown( self, path ) :
        os.chown( path, self.Uid, self.Gid )

    def ChownDirs( self, group, paths ) :
        if group is None :
            group = self.Gid
        cmd = [ "/bin/chown", "-R", self._user_name+":"+str(group) ]
        cmd += list(paths)
        print "Executing", cmd
        subprocess.call( cmd )

    def ChownDir( self, group, path ) :
        self.ChownDirs( group, (path,) )

    def SetupHomeDir( self ) :
        if not os.path.exists( self.Home ) :
            os.makedirs( self.Home )

    def Finished( self ) :
        self.ChownDir( None, self._home )

    @classmethod
    def LookUp( cls, username ) :
        try :
            return cls.__cache[username]
        except KeyError :
            user = cls( username )
            cls.__cache[username] = user
            return user

    Name  = property( lambda self : self._user_name )
    Uid   = property( lambda self : self._uid )
    Gid   = property( lambda self : self._gid )
    Home  = property( lambda self : self._home )

class _Main( object ) :

    def __init__( self ) :
        self._parser = _Parser( )

    def _ParseCmdLine( self ) :
        self._args = self._parser.ParseCmdLine( )

    Execute = property( lambda self : self._args.execute )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.quiet )

    def _SearchFile( self, path, string ) :
        try :
            fp = open( path )
            for line in fp :
                if string in line :
                    return line
            else :
                return None
        except IOError :
            return None

    def _AppendFile( self, path, string ) :
        try :
            fp = open( path, "a" )
            print >>fp, string
            fp.close( )
        except IOError as e :
            print "Failed to append to file", path, ":", e

    def _SetupSwap( self ) :
        if self._SearchFile( "/proc/mounts", "/swap" ) :
            cmd = ( "/bin/umount", "/swap" )
            if self.Verbose : print cmd
            subprocess.call( cmd )
        if os.path.exists( '/swap' ) :
            os.rmdir( '/swap' )
        line = self._SearchFile( '/etc/fstab', '/swap' )
        if line is None :
            return
        cmd = ( 'sed', '-i', 's|/swap.*|swap swap defaults 0 0|', '/etc/fstab' )
        if self.Verbose : print cmd
        subprocess.call( cmd )
        cmd = ( 'mkswap', line.split(' ')[0] )
        if self.Verbose : print cmd
        subprocess.call( cmd )
        cmd = ( 'swapon', '-a' )
        if self.Verbose : print cmd
        subprocess.call( cmd )

    _template_dirs = {
        'home' : '/local',
        'root' : '/',
    }
    def _SetupHomes( self ) :
        for name, dest in self._template_dirs.items() :
            src = os.path.join( '/home/qualys/template', name )
            cmd = ( 'rsync', '-av', 'celeborn:'+src, dest )
            subprocess.call( cmd )

    def _SetupBuildDirs( self, user_name ) :
        # Create and mount /build
        print "Creating /build"
        for path in ( "/build", "/local/build" ) :
            if not os.path.exists( path ) :
                os.makedirs( path )
        if not self._SearchFile( "/etc/fstab", "/build" ) :
            self._AppendFile( "/etc/fstab", "/local/build       /build    none    bind    0 0" )
        if not self._SearchFile( "/proc/mounts", "/build" ) :
            cmd = [ "/bin/mount", "/build" ]
            subprocess.call( cmd )

    def _ArchivePath( self, name, name2, timestamp ) :
        ib = User.LookUp( "ironbee" )
        if name2 is None :
            archive_name = '%s-%s-%s.tar.gz' % ( name, self._args.arch, timestamp )
        else :
            archive_name = '%s-ib_%s-%s-%s.tar.gz' % ( name, name2, self._args.arch, timestamp )
        return os.path.join( ib.Home, 'data', archive_name )

    def _PopulateDirectories( self, timestamp, archives, user_name, group=None ) :
        user = User.LookUp( user_name )
        for name,dirpath in archives.items() :
            if not os.path.exists( dirpath ) :
                os.makedirs( dirpath )
                user.ChownDir( "qualys", dirpath )
            if "build" in name :
                tarball = self._ArchivePath( name, self._args.ib_version, timestamp )
            else :
                tarball = self._ArchivePath( name, None, timestamp )
            cmd = ( "/bin/tar", "xf", tarball )
            print "Populating", dirpath, ":", cmd
            if self.Execute :
                subprocess.call( cmd, cwd=dirpath )

    def _SelectArchive( self ) :
        regex = re.compile( r'-(\d{6}_\d{6})' )
        if self._args.timestamp is not None :
            return self._args.timestamp
        
        latest = None
        rval = None
        for archive in glob.glob( self._ArchivePath('*', self._args.ib_version, '*') ) :
            match = regex.search( archive )
            if match is None :
                print "No archives found!"
                sys.exit(1)
            timestamp = time.strptime( match.group(1), '%y%m%d_%H%M%S' )
            if latest is None  or  timestamp > latest :
                latest = timestamp
                rval = match.group(1)
        return rval

    def Main( self ) :
        self._ParseCmdLine( )
        if os.geteuid() != 0  and  ( self._args.setup_homes or self._args.setup_build ) :
            print >>sys.stderr, "This program needs to be run by root"
            sys.exit( 1 )
        if self._args.setup_swap :
            self._SetupSwap( )
        if self._args.setup_homes :
            self._SetupHomes( )
        if self._args.setup_build :
            self._SetupBuildDirs( self._args.user )
        timestamp = self._SelectArchive( )
        if self._args.extract :
            self._PopulateDirectories( timestamp,
                                       {
                                           "build": "/build/qualys",
                                           "local": "/local/qualys",
                                           "etc.in": "/local/qualys",
                                       },
                                       self._args.user, "qualys" )


main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
