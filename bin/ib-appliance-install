#! /usr/bin/env python
###########################################################################
##
## Copyright(c) 2014 by Nick LeRoy, 310 Jones Ave, Fort Atkinson, WI
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
###########################################################################
import re
import os
import sys
import pwd
import grp
import glob
import subprocess
import argparse
import platform
import time
import shutil
import tarfile
import stat

try :
    import ib.util
except ImportError :
    path = os.path.realpath(os.path.dirname(os.path.abspath(__file__)))
    print path
    libpath = os.path.abspath(os.path.join(path,'../lib/python'))
    print libpath
    sys.path.append( libpath )

from ib.appliance.exceptions import *
from ib.appliance.build      import *
from ib.appliance.config     import *
from ib.parser.appliance     import *

class _Parser( IbApplianceParser ) :
    _parts = {
        'setup_homes' : {
            "arg"     : 'setup-homes',
            "default" : False,
            "help"    : "Setup root and user directories",
        },
        'setup_build' : {
            "arg"     : 'setup-build',
            "default" : False,
            "help"    : "Setup build tree",
        },
        'setup_swap' : {
            "arg"     : 'setup-swap',
            "default" : False,
            "help"    : "Setup swap space",
        },
        'extract' : {
            "arg"     : 'extract',
            "default" : True,
            "help"    : "Extract archives",
        },
    }

    def __init__( self ) :
        IbApplianceParser.__init__( self, 
                                    "Program to install IronBee on a VM host" )

        self.Parser.add_argument( "--user",
                                  action="store", dest="user", default=None,
                                  help='Specify user to setup <default=from config>' )
        self.Parser.add_argument( "--group",
                                  action="store", dest="group", default=None,
                                  help='Specify group to setup <default=from config>' )

        class PartsAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                if option_string in ("--enable-all", "--init") :
                    only = False
                    value = True
                    arg = None
                elif option_string.endswith( "-only" ) :
                    only = True
                    value = True
                    arg = option_string[2:-5]
                elif option_string.startswith( "--no-" ) :
                    value = False
                    only = False
                    arg = option_string[5:]
                else :
                    value = True
                    only = False
                    arg = option_string[2:]

                for name,part in _Parser._parts.items( ) :
                    if arg is None  or  arg == part['arg'] :
                        vars(namespace)[name] = value
                        for other in _Parser._parts.keys() :
                            if other != name  and  only :
                                vars(namespace)[other] = False

        group = self.Parser.add_argument_group( 'Mode', 'Enable for modes of operation' )
        for name,part in _Parser._parts.items( ) :
            arg = part['arg']
            default = part['default']
            help = part['help'] + ' <default=' + ('Yes' if default else 'No') + '>'
            group.add_argument( '--'+arg,
                                action=PartsAction, default=default, nargs=0,
                                help=help.capitalize() )
            group.add_argument( '--no-'+arg,
                                action=PartsAction, nargs=0,
                                help=('Do not '+help).capitalize() )
            group.add_argument( '--'+arg+'-only',
                                action=PartsAction, nargs=0,
                                help=('Only '+help).capitalize() )
        group.add_argument( '--enable-all', '--init',
                            action=PartsAction, nargs=0,
                            help='Enable all actions' )

class User( object ) :
    def __init__( self, user_name, group=None ) :
        self._user_name = user_name
        pwent = pwd.getpwnam(user_name)
        assert pwent is not None
        self._home  = pwent.pw_dir
        self._uid   = pwent.pw_uid
        self._setGroup( group, pwent.pw_gid )

    def _setGroup( self, group, gid=None ) :
        assert group is not None  or  gid is not None
        if gid is None :
            gwent = grp.getgrnam(group)
        else :
            gwent = grp.getgrgid(gid)
        assert gwent is not None
        self._gid        = gwent.gr_gid
        self._group_name = gwent.gr_name

    Group = property( lambda self : self._group, _setGroup )

    def Chown( self, path ) :
        os.chown( path, self.Uid, self.Gid )

    def ChownDirs( self, paths ) :
        cmd = [ "/bin/chown", "-R", ':'.join(self._user_name, self._group_name) ]
        cmd += list(paths)
        print "Executing", cmd
        subprocess.call( cmd )

    def ChownDir( self, path ) :
        self.ChownDirs( (path,) )

    def SetupHomeDir( self ) :
        if not os.path.exists( self.Home ) :
            os.makedirs( self.Home )

    def Finished( self ) :
        self.ChownDir( None, self._home )

    Name  = property( lambda self : self._user_name )
    Uid   = property( lambda self : self._uid )
    Group = property( lambda self : self._group_name )
    Gid   = property( lambda self : self._gid )
    Home  = property( lambda self : self._home )
                

class _Main( object ) :
    def __init__( self ) :
        self._parser = _Parser( )

    def _ParseCmdLine( self ) :
        self._args = self._parser.Parse( )

    def _ReadConfig( self ) :
        config = IbApplianceConfig( self._args.config )
        self._config = config.Read( )

    def _MergeConfig( self ) :
        self._specs = IbApplianceBuild( )
        defaults = self._config['install']['defaults']

        if self._args.user is not None :
            user = self._args.user
        elif defaults.get('User', None) :
            user = defaults['User']
        else :
            print >>sys.stderr, "No user specified, no default user in config"
            sys.exit(1)

        if self._args.group is not None :
            group = self._args.group
        else :
            group = defaults.get('Group')

        self._user = User( user, group )

        if self._args.ib_version is not None :
            self._specs.IronBeeVersion = IbVersion(self._args.ib_version)
        elif defaults.get('IronBeeVersion', None) :
            self._specs.IronBeeVersion = IbVersion(defaults.get('IronBeeVersion'))

        if self._args.ib_branch is not None :
            self._specs.IronBeeGitBranch = self._args.ib_branch
        else :
            self._specs.IronBeeGitBranch = defaults.get('IronBeeGitBranch', None)


    def _SearchFile( self, path, string ) :
        try :
            fp = open( path )
            for line in fp :
                if string in line :
                    return line
            else :
                return None
        except IOError :
            return None

    def _AppendFile( self, path, string ) :
        try :
            fp = open( path, "a" )
            print >>fp, string
            fp.close( )
        except IOError as e :
            print "Failed to append to file", path, ":", e

    def _Execute( self, cmd ) :
        if self._parser.Verbose :
            print "Running:", cmd
        if self._parser.Execute :
            subprocess.call( cmd )
        
    def _SetupSwap( self ) :
        if self._SearchFile( "/proc/mounts", "/swap" ) :
            cmd = ( "/bin/umount", "/swap" )
            if self._parser.Verbose : print cmd
            subprocess.call( cmd )
        if os.path.exists( '/swap' ) :
            os.rmdir( '/swap' )
        line = self._SearchFile( '/etc/fstab', '/swap' )
        if line is None :
            return
        cmd = ( 'sed', '-i', 's|/swap.*|swap swap defaults 0 0|', '/etc/fstab' )
        self._Execute( cmd )
        cmd = ( 'mkswap', line.split(' ')[0] )
        self._Execute( cmd )
        cmd = ( 'swapon', '-a' )
        self._Execute( cmd )

    _template_dirs = {
        'home' : '/local',
        'root' : '/',
    }
    def _SetupHomes( self ) :
        for name, dest in self._template_dirs.items() :
            src = os.path.join( '/home/qualys/template', name )
            cmd = ( 'rsync', '-av', 'celeborn:'+src, dest )
            self._Execute( cmd )

    def _SetupBuildDirs( self, user_name ) :
        # Create and mount /build
        print "Creating /build"
        for path in ( "/build", "/local/build" ) :
            if not os.path.exists( path ) :
                os.makedirs( path )
        if not self._SearchFile( "/etc/fstab", "/build" ) :
            self._AppendFile( "/etc/fstab", "/local/build       /build    none    bind    0 0" )
        if not self._SearchFile( "/proc/mounts", "/build" ) :
            cmd = [ "/bin/mount", "/build" ]
            self._Execute( cmd )

    def _WipeDirs( self, dirpath, dirs ) :
        assert type(dirpath) == str
        assert type(dirs) in (list, tuple, set)
        for name in dirs :
            fullpath = os.path.join( dirpath, name )
            if os.path.exists( fullpath ) :
                for root, ldirs, lfiles in os.walk( fullpath ) :
                    for f in lfiles :
                        fp = os.path.join(root,f)
                        if os.path.islink( fp ) :
                            pass
                        elif not os.access( fp, os.W_OK ) :
                            os.chmod( fp, stat.S_IRUSR | stat.S_IWUSR )
                    for f in ldirs :
                        fp = os.path.join(root,f)
                        if os.path.islink( fp ) :
                            pass
                        elif not os.access( fp, os.W_OK ) :
                            os.chmod( fp, stat.S_IRWXU )
                shutil.rmtree( fullpath )

    def _PopulateDirectory( self, build, name, wipe=False ) :
        archive = build.GetArchive( name )
        if not os.path.exists( archive.DestDir ) :
            os.makedirs( archive.DestDir )
            user.ChownDir( archive.DestDir )
        tarball = os.path.join( build.ArchiveDirectory, archive.FileName )
        if not os.path.isfile( tarball ) :
            print >>sys.stderr, "Archive", tarball, "doesn not exist"
            sys.exit(1)
        try :
            print "Populating", archive.DestDir, "from", tarball
            regex = re.compile( r'(\.?/)?([^\/]+)/' )
            tar = tarfile.open( tarball )
            top = set()
            for member in tar.getmembers() :
                if member.name.startswith("/") :
                    print >>sys.stderr, \
                        'Archive', fullpath, 'has fully qualified path! "%s"' % (member.name)
                    sys.exit(1)
                m = regex.match( member.name )
                if m is not None :
                    top.add( m.group(2) )
            if self._parser.Execute :
                if wipe is None or wipe == False :
                    pass
                elif wipe == True :
                    self._WipeDirs( archive.DestDir, top )
                elif type(wipe) in (list, tuple) :
                    self._WipeDirs( archive.DestDir, wipe )
                else :
                    assert False, str(wipe)
                tar.extractall( path=archive.DestDir )
                if os.geteuid() == 0 :
                    user.ChownDir( archive.DestDir )
        except tarfile.TarError as e :
            print >>sys.stderr, 'Error extracting from tarball "%s": %s' % ( tarball, e )
            sys.exit(1)

    def _ExtractTarballs( self, build ) :
        self._PopulateDirectory( build, "build",  wipe=True )
        self._PopulateDirectory( build, "local",  wipe=('opt', 'share', 'etc', 'etc.in') )
        self._PopulateDirectory( build, "etc-in", wipe=True )
        etc = os.environ['QLYS_ETC']
        if self._parser.Execute :
            if os.path.exists( etc ) :
                shutil.rmtree( etc )
            os.makedirs( etc )
            build.WriteArchiveData( etc )

    def _BuildFilter( self, build ) :
        if self._specs.IronBeeVersion is not None and \
           self._specs.IronBeeVersion != build.IronBeeVersion :
            if self._parser.Verbose >= 2 :
                print "Skipping build", build.Name, "IronBee versions don't match:", \
                    self._specs.IronBeeVersion, build.IronBeeVersion
            return False

        if self._specs.IronBeeGitBranch is not None and \
           build.IronBeeGitBranch != self._specs.IronBeeGitBranch :
            if self._parser.Verbose >= 2 :
                print "Skipping build", build.Name, "IronBee versions don't match:", \
                    build.IronBeeGitBranch, '!=', self._specs.IronBeeGitBranch
            return False
        return True
            

    def _SelectArchive( self ) :
        appliances = IbApplianceBuildSet( self._args.builds )
        appliances.ReadAll( )
        max_build = None
        for a in appliances.Builds( self._BuildFilter ) :
            if max_build is None :
                max_build = a
            elif a.IronBeeVersion > max_build.IronBeeVersion :
                max_build = a
            elif a.TimeStamp > max_build.TimeStamp :
                max_build = a
        if not self._parser.Quiet :
            print "Selected", max_build.Name
        return max_build

    def Main( self ) :
        self._ParseCmdLine( )
        self._ReadConfig( )
        self._MergeConfig( )
        build = self._SelectArchive( )
        if build is None :
            print >>sys.stderr, "No matching archives found!"
            sys.exit( 1 )
        if os.geteuid() != 0 :
            table = {
                'setup-homes' : self._args.setup_homes,
                'setup-build' : self._args.setup_build,
                'setup-swap' : self._args.setup_swap,
            }
            errors = []
            for n,v in table.items( ) :
                if v :
                    errors.append( n )
            if len(errors) :
                print >>sys.stderr, \
                    "This program needs to be run by root to perform selected operations:"
                for e in errors :
                    print >>sys.stderr, '\t'+e
                sys.exit( 1 )
        if self._args.setup_swap :
            self._SetupSwap( )
        if self._args.setup_homes :
            self._SetupHomes( )
        if self._args.setup_build :
            self._SetupBuildDirs( self._args.user )
        if self._args.extract :
            self._ExtractTarballs( build )

main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
