#! /usr/bin/env python
# ****************************************************************************
# Licensed to Qualys, Inc. (QUALYS) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# QUALYS licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ****************************************************************************
import re
import os
import sys
import time
import subprocess
import argparse
import collections
import netifaces
import socket

from ibutil import *

class Main( object ) :
    def __init__( self ) :
        self._defs = IbDict( )
        self._stack = [ ]

    def Setup( self ) :
        self._parser = argparse.ArgumentParser( description="IronBee Configuration Generator",
                                                prog="ib-genconf" )

        self._parser.set_defaults( patterns = collections.OrderedDict() )
        class SubstAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                try :
                    x, pattern, subst, opts = values[0].split( '/' )
                    flags = 0
                    if opts == 'I' :
                        flags |= re.I
                    elif opts != "" :
                        parser.error( "Invalid regex options '"+opts+"'" )
                    compiled = re.compile( pattern, flags )
                    namespace.patterns[compiled] = subst
                except ValueError :
                    parser.error( "Invalid regex '"+values[0]+"'" )
        self._parser.add_argument( "--subst", action=SubstAction, nargs=1,
                                   help="Specify /pattern/subst/flags regexs" )

        self._parser.set_defaults( defs = [] )
        class StrAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                for s in values :
                    try :
                        name, value = s.split( '=', 1 )
                        namespace.defs.append( (name.strip(), value) )
                    except ValueError :
                        parser.error( "Invalid argument '"+s+"'" )

        self._parser.add_argument( "strings", metavar='n=v', type=str,
                                   action=StrAction, nargs='*',
                                   help="Specify name=value definitions" )

        self._parser.add_argument( "infile", type=argparse.FileType('r'),
                                   help='input file')

        self._parser.add_argument( "--out", "-o",
                                   dest="outfile", type=argparse.FileType('w'),
                                   default=sys.stdout,
                                   help='output file')

        self._parser.add_argument( "-",
                                   action="store_true", dest="noop", default=False,
                                   help='Do nothing')

        class EnvAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                for s in values :
                    if type(s) != str :
                        break
                    namespace.env_vars.append( s )
        self._parser.add_argument( "--env", "-e",
                                   action=EnvAction, dest="env_vars", default=[], nargs='+',
                                   help='Specify list of env. variables to import')

        self._parser.add_argument( "--force-header",
                                   action="store_true", dest="force_header", default=False,
                                   help="Force insertion of genconf header")

        self._parser.add_argument( "--rule-append",
                                   action="append", dest="rule_append", default=[],
                                   help="Append string to all rule definitions")

        self._parser.add_argument( "--uncomment",
                                   action="append", dest="uncomment_pats", default=[],
                                   help="Specify pattern to uncomment" )

        self._parser.add_argument( "--execute",
                                   action="store_true", dest="execute", default=True,
                                   help="Enable execution <default>" )
        self._parser.add_argument( "-n", "--no-execute",
                                   action="store_false", dest="execute",
                                   help="Disable execution (for test/debug)" )

        self._parser.add_argument( "-v", "--verbose",
                                   action="count", dest="verbose", default=0,
                                   help="Increment verbosity level" )

        self._parser.add_argument( "-q", "--quiet",
                                   action="store_true", dest="quiet", default=False,
                                   help="be vewwy quiet (I'm hunting wabbits)" )

    def Parse( self ) :
        self._args = self._parser.parse_args()
        for name in self._args.env_vars :
            if name not in os.environ :
                self._parser.error( '"%s" not in environment!'%(name) )
            self._defs.Set( name, os.environ[name] )
        for name,value in self._args.defs :
            self._defs.Set( name, value )

    Execute = property( lambda self : self._args.verbose )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.verbose )

    __ExpandRe = re.compile( r'\$\{([^\{\}]+)\}' )
    def Expand( self, line ) :
        while True :
            m = self.__ExpandRe.search( line )
            if m is None :
                return line
            key = m.group(1)
            try :
                value = self._defs[key]
            except KeyError :
                value = ""
            line = line.replace( '${'+key+'}', value )


    __IncludeRe1 = re.compile( r'\$\{include\s+"(.*)"\s*\}$', re.I)
    __IncludeRe2 = re.compile( r'\$\{include\s+(\S+)\s*\}$', re.I)
    __IfRe       = re.compile( r'\$\{if\s+"([^"]+)"\s+(.*)\}$', re.I )
    __IfRe2      = re.compile( r'\$\{if\s+(\S+)\s+(.*)\}$', re.I )
    __IfStartRe  = re.compile( r'\$\{if\s+"([^"]+)"\s*\}$', re.I )
    __IfStartRe2 = re.compile( r'\$\{if\s+(\S+)\s*\}$', re.I )
    __IfEndRe    = re.compile( r'\$\{endif\s*\}$', re.I )
    __SetRe1     = re.compile( r'\$\{set (\w+)\s+(.*?)\s*\}$', re.I)
    __SetRe2     = re.compile( r'\$\{set (\w+)\s+"(.*)"\s*\}$', re.I)
    __RuleRe     = re.compile( r'(Rule|StreamInspect) ', re.I )
    __WsRe       = re.compile( r'(\s*)' )
    __AutoHeader = \
        '# ${OutFile} Auto-generated @${Time} by genconf ' + \
        'from ${InFile}.  DO NOT EDIT!!\n'

    def ProcessLine( self, fp, lno, baseid, line ) :
        expand = True
        try :
            enable = self._stack[-1]
        except IndexError :
            enable = True

        # All whitespace?  Do nothing
        ws = self.__WsRe.match( line ).group(1)
        line = line.lstrip()
        if line == '' :
            if enable :
                return '\n'
            else :
                return '#\n'

        # Create "Line", "RID", "PRID"
        self._defs.Set('Line', '%03d' % (lno+1))
        ruleid = '%s/%03d' % (baseid, lno+1)
        self._defs.Set('RID', ruleid, fn = lambda d,v : d.Set('PRID', v))

        # Add genconf header line
        if lno == 0 :
            if re.match( r'#!\s*genconf', line ) :
                line = self.__AutoHeader
            elif self._args.force_header  and  \
                    ( len(line) <= 1 or line.startswith('#') ):
                line = self.__AutoHeader

        # Check for ${if "<expr>"}
        m = self.__IfStartRe.match( line )
        if m is None :
            m = self.__IfStartRe2.match( line )
        if m is not None :
            try :
                expr = self.Expand( m.group(1) )
                v = eval(expr)
            except (SyntaxError, NameError) as e :
                v = False
            self._stack.append( v )
            penable = enable
            if enable :
                enable = v
            if self.Verbose >= 2 :
                print "  if: enable was %s, now %s" % ( str(penable), str(enable) )

        # Check for ${endif "<expr>"}
        elif self.__IfEndRe.match( line ) :
            try :
                penable = enable
                enable = self._stack.pop()
                if self.Verbose >= 2 :
                    print "  endif: enable was %s, now %s" % ( str(penable), str(enable) )
            except IndexError :
                print >>sys.stderr, 'Mismatched ${endif} @ '+fp.name+':', lno
                sys.exit(1)

        # Check for ${if "<expr>" text}
        m = self.__IfRe.match( line )
        if m is None :
            m = self.__IfRe2.match( line )
        if m is not None :
            try :
                expr = self.Expand( m.group(1) )
                v = eval(expr)
            except (SyntaxError, NameError) as e :
                v = False
            if v :
                line = m.group(2)+'\n'
            elif enable :
                enable = v

        # Process includes
        m = self.__IncludeRe1.match( line )
        if m is None :
            m = self.__IncludeRe2.match( line )
        if m is not None :
            base = os.path.dirname( fp.name )
            fname = os.path.join( base, m.group(1) )
            try :
                f = open(fname)
                self.ProcessFile( f, baseid, False )
                return '#\n'
            except IOError as e :
                print >>sys.stderr, 'Error reading file "'+fname+'": ', e
                sys.exit( 1 )

        # Process the append arg
        if len(self._args.rule_append) :
            if self.__RuleRe.match( line ) :
                if line.rstrip().endswith('\\') :
                    start,sep,end = line.rpartition('\\')
                    cont = True
                    line = start + ' ' + (' '.join(self._args.rule_append)) + ' \\\n'
                else :
                    line = line.rstrip() + ' ' + (' '.join(self._args.rule_append)) + '\n'

        # Check for a definition
        m = self.__SetRe1.match( line )
        if m is None :
            m = self.__SetRe2.match( line )
        if m is not None :
            expanded = self.Expand(m.group(2))
            self._defs.Set( m.group(1), expanded )
            expand = False
            enable = False

        for pat in self._args.uncomment_pats :
            if re.match( r'\s+#', line )  and  re.search( pat, line ) :
                line = ws + re.sub( '#\s+', '', line )

        for regex,subst in self._args.patterns.items( ) :
            line = regex.sub( subst, line )

        if expand :
            line = self.Expand( line )
        if not enable :
            return '#' + ws + line
        else :
            return ws + line


    def ProcessFile( self, fp, baseid, write ) :
        for lno,line in enumerate( fp ) :
            if self.Verbose >= 2:
                print 'Processing line %d of file "%s"' % ( lno, fp.name )
            if self.Verbose >= 3:
                print   '     "%s"' % ( line.rstrip() )
            line = self.ProcessLine( fp, lno, baseid, line )
            if write :
                if self.Verbose >= 3:
                    print '  => "%s"' % ( line.rstrip() )
                self._args.outfile.write( line )

    def Run( self ) :
        pid = ""
        basename = os.path.basename( self._args.infile.name )
        self._defs.Set('OutFile', os.path.basename(self._args.outfile.name))
        self._defs.Set('InFile', basename)
        baseid = re.sub( r'\..+', r'', basename)
        self._defs.Set('Base', baseid, over=False)
        for name in netifaces.interfaces() :
            try :
                ip = netifaces.ifaddresses(name)[netifaces.AF_INET][0]['addr']
                self._defs.Set("iface:"+name, ip, over=False)
                if ip.startswith("192.168") :
                    self._defs.Set("iface:private", ip, over=False)
                elif name.startswith("eth") :
                    self._defs.Set("iface:public", ip, over=False)
                if name.startswith("eth") :
                    self._defs.Set("iface:eth", ip, over=False)
            except KeyError :
                continue
        self._defs.Set("HostName", socket.gethostname(), over=False)
        self._defs.Set("Time", time.asctime(), over=False)
        self.ProcessFile( self._args.infile, baseid, True )
        if not self._args.quiet :
            print self._args.infile.name, "-->", self._args.outfile.name
        
    def Main( self ) :
        self.Setup( )
        self.Parse( )
        self.Run( )

main = Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
