#! /usr/bin/env python
###########################################################################
##
## Copyright(c) 2014 by Nick LeRoy, 310 Jones Ave, Fort Atkinson, WI
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
###########################################################################
import re
import os
import sys
import pwd
import grp
import glob
import subprocess
import argparse
import time
import shutil
import tarfile
import stat

from ib.homevm.exceptions import *
from ib.homevm.archive    import *
from ib.homevm.config     import *
from ib.homevm.parser     import *

class _Parser( IbHomeVmParser ) :

    def __init__( self ) :
        IbHomeVmParser.__init__( self, 
                                    "Program to install IronBee on a VM host" )

        group = self.Parser.add_argument_group( )
        group.add_argument( dest="ib_branch", default=None,
                            help="Specify alternate IronBee git branch name <None>" )
        group.add_argument( action="store", dest="ib_version", default=None, nargs='?',
                            help="Specify IronBee version to use <None>" )

        group = self.Parser.add_argument_group( )
        group.add_argument( "--user",
                            action="store", dest="user", default=None,
                            help='Specify user to setup <default=from config>' )
        group.add_argument( "--group",
                            action="store", dest="group", default=None,
                            help='Specify group to setup <default=from config>' )

        group = self.Parser.add_argument_group( )
        group.add_argument( "--gcc-version",
                            action="store", dest="gcc_version", default=None,
                            help="Specify GCC version to use <Auto>" )
        group.add_argument( "--clang-version",
                            action="store", dest="clang_version", default=None,
                            help="Specify clang version to use <Auto>" )
        group.add_argument( "--clang-tsan",
                            action="store_true", dest="clang_tsan", default=False,
                            help="Require clang thread santized version to use <Auto>" )
        group.add_argument( "--compiler",
                            action="store", dest="compiler", default=None,
                            choices=('clang','gcc'),
                            help="Specify compiler to use <Auto>" )

        self.Parser.add_argument( "--ats-version",
                                  action="store", dest="ats_version", default=None,
                                  help="Specify ATS version to use <Auto>" )

class _Main( object ) :
    def __init__( self ) :
        self._parser = _Parser( )

    def _ParseCmdLine( self ) :
        self._args = self._parser.Parse( )

    def _ReadConfig( self ) :
        config = IbHomeVmConfig( self._args.config )
        self._config = config.Read( )

    def _MergeConfig( self ) :
        self._specs = IbHomeVmArchive( )
        defaults = self._config['install']['defaults']

        if self._args.ib_version is not None :
            self._specs.IronBeeVersion = IbVersion(self._args.ib_version)
        elif defaults.get('IronBeeVersion', None) :
            self._specs.IronBeeVersion = IbVersion(defaults.get('IronBeeVersion'))

        if self._args.ib_branch is not None :
            self._specs.IronBeeGitBranch = self._args.ib_branch
        else :
            self._specs.IronBeeGitBranch = defaults.get('IronBeeGitBranch', None)

        self._specs.Architecture = self._args.arch
        self._specs.Bits = self._args.bits

        if self._args.compiler is not None :
            self._specs.Compiler = self._args.compiler
        elif 'COMPILER' in os.environ :
            self._specs.Compiler = os.environ['COMPILER']

        if self._specs.Compiler == 'gcc'  and  self._args.gcc_version is not None :
            self._specs.GccVersion = self._args.gcc_version
        elif 'GCC_VERSION' in os.environ :
            self._specs.GccVersion = os.environ['GCC_VERSION']

        if self._specs.Compiler == 'clang'  and  self._args.clang_version is not None :
            self._specs.ClangVersion = self._args.clang_version
        elif 'CLANG_VERSION' in os.environ :
            self._specs.ClangVersion = os.environ['CLANG_VERSION']

        if self._specs.Compiler == 'clang'  and  self._args.clang_tsan :
            self._specs.ClangThreadSantizer = True

        if self._args.ats_version is not None :
            self._specs.AtsVersion = self._args.ats_version
        elif 'ATS_VERSION' in os.environ :
            self._specs.AtsVersion = os.environ['ATS_VERSION']


    def _WipeDirs( self, dirpath, dirs ) :
        assert type(dirpath) == str
        assert type(dirs) in (list, tuple, set)
        for name in dirs :
            fullpath = os.path.join( dirpath, name )
            if os.path.exists( fullpath ) :
                for root, ldirs, lfiles in os.walk( fullpath ) :
                    for f in lfiles :
                        fp = os.path.join(root,f)
                        if os.path.islink( fp ) :
                            pass
                        elif not os.access( fp, os.W_OK ) :
                            os.chmod( fp, stat.S_IRUSR | stat.S_IWUSR )
                    for f in ldirs :
                        fp = os.path.join(root,f)
                        if os.path.islink( fp ) :
                            pass
                        elif not os.access( fp, os.W_OK ) :
                            os.chmod( fp, stat.S_IRWXU )
                shutil.rmtree( fullpath )

    def _PopulateDirectory( self, archive, name, wipe=False ) :
        tball = archive.GetArchive( name )
        if not os.path.exists( tball.DestDir ) :
            os.makedirs( tball.DestDir )
            user.ChownDir( tball.DestDir )
        tarball = os.path.join( archive.ArchiveDirectory, tball.FileName )
        if not os.path.isfile( tarball ) :
            print >>sys.stderr, "Archive", tarball, "doesn not exist"
            sys.exit(1)
        try :
            print "Populating", tball.DestDir, "from", tarball
            regex = re.compile( r'(\.?/)?([^\/]+)/' )
            tar = tarfile.open( tarball )
            top = set()
            for member in tar.getmembers() :
                if member.name.startswith("/") :
                    print >>sys.stderr, \
                        'Archive', fullpath, 'has fully qualified path! "%s"' % (member.name)
                    sys.exit(1)
                m = regex.match( member.name )
                if m is not None :
                    top.add( m.group(2) )
            if self.Execute :
                if wipe is None or wipe == False :
                    pass
                elif wipe == True :
                    self._WipeDirs( tball.DestDir, top )
                elif type(wipe) in (list, tuple) :
                    self._WipeDirs( tball.DestDir, wipe )
                else :
                    assert False, str(wipe)
                tar.extractall( path=tball.DestDir )
                if os.geteuid() == 0 :
                    user.ChownDir( tball.DestDir )
        except tarfile.TarError as e :
            print >>sys.stderr, 'Error extracting from tarball "%s": %s' % ( tarball, e )
            sys.exit(1)

    def _ExtractTarballs( self, archive ) :
        self._PopulateDirectory( archive, "local",  wipe=('opt', 'share', 'etc') )
        etc = os.environ['QLYS_ETC']
        if self.Execute :
            if os.path.exists( etc ) :
                shutil.rmtree( etc )
            os.makedirs( etc )
            archive.WriteArchiveData( etc )

    def _ArchiveFilter( self, archive ) :
        if self._specs.IronBeeVersion is not None and \
           self._specs.IronBeeVersion != archive.IronBeeVersion :
            if self.Verbose >= 2 :
                print "Skipping archive", archive.Name, "IronBee versions don't match:", \
                    self._specs.IronBeeVersion, archive.IronBeeVersion
            return False

        if self._specs.IronBeeGitBranch is not None and \
           archive.IronBeeGitBranch != self._specs.IronBeeGitBranch :
            if self.Verbose >= 2 :
                print "Skipping archive", archive.Name, "IronBee versions don't match:", \
                    archive.IronBeeGitBranch, '!=', self._specs.IronBeeGitBranch
            return False

        if self._specs.Compiler != archive.Compiler :
            if self.Verbose >= 2 :
                print "Skipping archive", archive.Name, "compilers don't match:", \
                    archive.Compiler, '!=', self._specs.Compiler
            return False

        if self._specs.Compiler == 'gcc' and self._specs.GccVersion != archive.GccVersion :
            if self.Verbose >= 2 :
                print "Skipping archive", archive.Name, "GCC versions don't match:", \
                    archive.GccVersion, '!=', self._specs.GccVersion
            return False

        if self._specs.Compiler == 'clang' :
            if self._specs.ClangVersion != archive.ClangVersion :
                if self.Verbose >= 2 :
                    print "Skipping archive", archive.Name, "clang versions don't match:", \
                        archive.ClangVersion, '!=', self._specs.ClangVersion
                return False
            if self._specs.ClangThreadSanitizer != archive.ClangThreadSanitizer :
                if self.Verbose >= 2 :
                    print "Skipping archive", archive.Name, "clang versions don't match:", \
                        archive.ClangVersion, '!=', self._specs.ClangVersion
                return False

        if self._specs.Architecture != archive.Architecture :
            if self.Verbose >= 2 :
                print "Skipping archive", archive.Name, "Architectures don't match:", \
                    archive.Architecture, '!=', self._specs.Architecture
            return False

        if self._specs.Bits != archive.Bits :
            if self.Verbose >= 2 :
                print "Skipping archive", archive.Name, "Bits don't match:", \
                    archive.Bits, '!=', self._specs.Bits
            return False
        return True
            

    def _SelectArchive( self ) :
        vms = IbHomeVmArchiveSet( self._args.archives )
        vms.ReadAll( )
        archive = None
        for a in vms.Archives( self._ArchiveFilter ) :
            if archive is None :
                archive = a
            elif a.IronBeeVersion > archive.IronBeeVersion :
                archive = a
            elif a.TimeStamp > archive.TimeStamp :
                archive = a
        if not self.Quiet  and  archive is not None:
            print "Selected", archive.Name
        return archive

    def _CheckoutEtcIn( self, archive ) :
        local = archive.QualysLocal
        if not os.path.isdir( os.path.join(local, 'etc.in') ) :
            cmd = ( 'git', 'clone', archive.EtcInRepo )
            subprocess.call( cmd, cwd=local )

    Execute = property( lambda self : self._args.execute )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.quiet )

    def Main( self ) :
        self._ParseCmdLine( )
        self._ReadConfig( )
        self._MergeConfig( )
        archive = self._SelectArchive( )
        if archive is None :
            print >>sys.stderr, "No matching archives found!"
            sys.exit( 1 )
        self._ExtractTarballs( archive )
        self._CheckoutEtcIn( archive )

main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
