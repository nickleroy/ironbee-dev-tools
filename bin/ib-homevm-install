#! /usr/bin/env python
###########################################################################
##
## Copyright(c) 2014 by Nick LeRoy, 310 Jones Ave, Fort Atkinson, WI
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
###########################################################################
import re
import os
import sys
import pwd
import grp
import glob
import subprocess
import argparse
import platform
import time
import shutil
import tarfile
import stat

from ib.homevm.exceptions import *
from ib.homevm.build      import *
from ib.homevm.config     import *
from ib.homevm.parser     import *

class _Parser( IbHomeVmParser ) :

    def __init__( self ) :
        IbHomeVmParser.__init__( self, 
                                    "Program to install IronBee on a VM host" )

        self.Parser.add_argument( dest="ib_branch", default=None,
                                  help="Specify alternate IronBee git branch name <None>" )

        self.Parser.add_argument( action="store", dest="ib_version", default=None, nargs='?',
                                  help="Specify IronBee version to use <None>" )

        self.Parser.add_argument( "--user",
                                  action="store", dest="user", default=None,
                                  help='Specify user to setup <default=from config>' )

        self.Parser.add_argument( "--group",
                                  action="store", dest="group", default=None,
                                  help='Specify group to setup <default=from config>' )

class _Main( object ) :
    def __init__( self ) :
        self._parser = _Parser( )

    def _ParseCmdLine( self ) :
        self._args = self._parser.Parse( )

    def _ReadConfig( self ) :
        config = IbHomeVmConfig( self._args.config )
        self._config = config.Read( )

    def _MergeConfig( self ) :
        self._specs = IbHomeVmBuild( )
        defaults = self._config['install']['defaults']

        if self._args.ib_version is not None :
            self._specs.IronBeeVersion = IbVersion(self._args.ib_version)
        elif defaults.get('IronBeeVersion', None) :
            self._specs.IronBeeVersion = IbVersion(defaults.get('IronBeeVersion'))

        if self._args.ib_branch is not None :
            self._specs.IronBeeGitBranch = self._args.ib_branch
        else :
            self._specs.IronBeeGitBranch = defaults.get('IronBeeGitBranch', None)

        self._specs.Architecture = self._args.arch
        self._specs.Bits = self._args.bits

    def _WipeDirs( self, dirpath, dirs ) :
        assert type(dirpath) == str
        assert type(dirs) in (list, tuple, set)
        for name in dirs :
            fullpath = os.path.join( dirpath, name )
            if os.path.exists( fullpath ) :
                for root, ldirs, lfiles in os.walk( fullpath ) :
                    for f in lfiles :
                        fp = os.path.join(root,f)
                        if os.path.islink( fp ) :
                            pass
                        elif not os.access( fp, os.W_OK ) :
                            os.chmod( fp, stat.S_IRUSR | stat.S_IWUSR )
                    for f in ldirs :
                        fp = os.path.join(root,f)
                        if os.path.islink( fp ) :
                            pass
                        elif not os.access( fp, os.W_OK ) :
                            os.chmod( fp, stat.S_IRWXU )
                shutil.rmtree( fullpath )

    def _PopulateDirectory( self, build, name, wipe=False ) :
        archive = build.GetArchive( name )
        if not os.path.exists( archive.DestDir ) :
            os.makedirs( archive.DestDir )
            user.ChownDir( archive.DestDir )
        tarball = os.path.join( build.ArchiveDirectory, archive.FileName )
        if not os.path.isfile( tarball ) :
            print >>sys.stderr, "Archive", tarball, "doesn not exist"
            sys.exit(1)
        try :
            print "Populating", archive.DestDir, "from", tarball
            regex = re.compile( r'(\.?/)?([^\/]+)/' )
            tar = tarfile.open( tarball )
            top = set()
            for member in tar.getmembers() :
                if member.name.startswith("/") :
                    print >>sys.stderr, \
                        'Archive', fullpath, 'has fully qualified path! "%s"' % (member.name)
                    sys.exit(1)
                m = regex.match( member.name )
                if m is not None :
                    top.add( m.group(2) )
            if self.Execute :
                if wipe is None or wipe == False :
                    pass
                elif wipe == True :
                    self._WipeDirs( archive.DestDir, top )
                elif type(wipe) in (list, tuple) :
                    self._WipeDirs( archive.DestDir, wipe )
                else :
                    assert False, str(wipe)
                tar.extractall( path=archive.DestDir )
                if os.geteuid() == 0 :
                    user.ChownDir( archive.DestDir )
        except tarfile.TarError as e :
            print >>sys.stderr, 'Error extracting from tarball "%s": %s' % ( tarball, e )
            sys.exit(1)

    def _ExtractTarballs( self, build ) :
        self._PopulateDirectory( build, "build",  wipe=True )
        self._PopulateDirectory( build, "local",  wipe=('opt', 'share', 'etc', 'etc.in') )
        self._PopulateDirectory( build, "etc-in", wipe=True )
        etc = os.environ['QLYS_ETC']
        if self.Execute :
            if os.path.exists( etc ) :
                shutil.rmtree( etc )
            os.makedirs( etc )
            build.WriteArchiveData( etc )

    def _BuildFilter( self, build ) :
        if self._specs.IronBeeVersion is not None and \
           self._specs.IronBeeVersion != build.IronBeeVersion :
            if self.Verbose >= 2 :
                print "Skipping build", build.Name, "IronBee versions don't match:", \
                    self._specs.IronBeeVersion, build.IronBeeVersion
            return False

        if self._specs.IronBeeGitBranch is not None and \
           build.IronBeeGitBranch != self._specs.IronBeeGitBranch :
            if self.Verbose >= 2 :
                print "Skipping build", build.Name, "IronBee versions don't match:", \
                    build.IronBeeGitBranch, '!=', self._specs.IronBeeGitBranch
            return False

        if self._specs.Architecture != build.Architecture :
            if self.Verbose >= 2 :
                print "Skipping build", build.Name, "Architectures don't match:", \
                    build.Architecture, '!=', self._specs.Architecture
            return False

        if self._specs.Bits != build.Bits :
            if self.Verbose >= 2 :
                print "Skipping build", build.Name, "Bits don't match:", \
                    build.Bits, '!=', self._specs.Bits
            return False

        return True
            

    def _SelectArchive( self ) :
        vms = IbHomeVmBuildSet( self._args.builds )
        vms.ReadAll( )
        build = None
        for a in vms.Builds( self._BuildFilter ) :
            if build is None :
                build = a
            elif a.IronBeeVersion > build.IronBeeVersion :
                build = a
            elif a.TimeStamp > build.TimeStamp :
                build = a
        if not self.Quiet  and  build is not None:
            print "Selected", build.Name
        return build

    Execute = property( lambda self : self._args.execute )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.quiet )

    def Main( self ) :
        self._ParseCmdLine( )
        self._ReadConfig( )
        self._MergeConfig( )
        build = self._SelectArchive( )
        if build is None :
            print >>sys.stderr, "No matching archives found!"
            sys.exit( 1 )
        self._ExtractTarballs( build )

main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
