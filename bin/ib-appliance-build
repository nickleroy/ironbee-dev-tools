#! /usr/bin/env python
# ****************************************************************************
# Licensed to Qualys, Inc. (QUALYS) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# QUALYS licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ****************************************************************************
import re
import os
import sys
import shutil
import subprocess
import argparse
import time
import glob
import git
import ib_version
import ib_appliance
import ib_base_parser

class DetectionError(BaseException) : pass


class _Main( object ) :
    def __init__( self ) :
        self._parser = argparse.ArgumentParser(
            description="Program to build an archive for appliances",
            prog="ib-appliance-build" )

        self._parser.add_argument( "--timestamp",
                                   action="store", dest="timestamp",
                                   default=time.strftime('%y%m%d-%H%M%S'),
                                   help="Specify timestamp <yymmdd-hhmmss>" )

        self._parser.add_argument( "--arch",
                                   action="store", dest="arch", default=os.environ['SYS_ARCH'],
                                   help="Specify architector to use <"+os.environ['SYS_ARCH']+">" )

        self._parser.add_argument( "--ib-version",
                                   action="store", dest="ib_version", default=None,
                                   help="Specify IronBee version to use <auto>" )

        self._parser.add_argument( "--branch",
                                   action="store", dest="branch", default=None,
                                   help="Specify git branch to use <auto>" )

        self._parser.add_argument( "--gcc-version",
                                   action="store", dest="gcc_version", default=None,
                                   help="Specify GCC version to use <auto>" )
        
        self._parser.add_argument( "--build-root",
                                   action="store", dest="build_root", default=os.environ['QLYS_BUILD'],
                                   help="Specify alternate directory <"+os.environ['QLYS_BUILD']+">" )

        config = os.path.join(os.environ['QLYS_ETC'], 'ib-appliance.conf')
        self._parser.add_argument( "--config",
                                   action="store", dest="config", default=config,
                                   help="Specify configuration file to use <"+config+">" )

        builds = os.environ['QLYS_BUILDS']
        self._parser.add_argument( "--builds",
                                   action="store", dest="builds", default=builds,
                                   help="Specify builds directory <"+builds+">" )

        self._parser.add_argument( "--list",
                                   action="store_true", dest="list", default=False,
                                   help="List archives <default=no>" )

        self._parser.set_defaults( clean=False )
        self._parser.add_argument( "--clean", "-c",
                                   action="store_true", dest="clean",
                                   help="Cleanup old archives <default=no>" )
        self._parser.add_argument( "--no-clean",
                                   action="store_false", dest="clean",
                                   help="Disable cleanup of old archives" )

        self._parser.add_argument( "--execute",
                                   action="store_true", dest="execute", default=True,
                                   help="Enable execution <default=yes>" )
        self._parser.add_argument( "-n", "--no-execute",
                                   action="store_false", dest="execute",
                                   help="Disable execution (for test/debug) <Default=execute>" )
        self._parser.add_argument( "-v", "--verbose",
                                   action="count", dest="verbose", default=0,
                                   help="Increment verbosity level" )
        self._parser.add_argument( "-q", "--quiet",
                                   action="store_true", dest="quiet", default=False,
                                   help="be vewwy quiet (I'm hunting wabbits) <default=no-quiet>" )

    def _ParseCmdline( self ) :
        self._args = self._parser.parse_args()
        if not self.Execute  and  self.Verbose == 0  and  not self.Quiet :
            self._verbose = 1

    def _ReadConfig( self ) :
        validator = Validator()
        config = ConfigObj( self._args.config )
        if 'build' not in config :
            print >>sys.stderr, "No targets section found"
            sys.exit(1)

    Execute = property( lambda self : self._args.execute )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.quiet )

    def _Execute( self, cmd, cwd=None ) :
        if not self.Quiet :
            if cwd is None :
                print 'Executing', cmd
            else :
                print 'Executing', cmd, 'from', cwd
        if self.Execute :
            subprocess.call( cmd, cwd=cwd )

    def _CreateArchive( self, name, directory, targets, rules=None ) :
        if rules is None :
            rules = _RuleSet( )
        archive = os.path.join(self._archive_dir, name+'.tar.bz2')
        print 'Creating', name, 'archive', archive
        tar_cmd = 'cvfj' if self.Verbose else 'cfj'
        cmd = [ "/bin/tar", tar_cmd, archive ] + list(targets) + list(rules.Rules)
        self._Execute( cmd, directory )

    def _PopulateLocal( self, basedir, targetdir, rules ) :
        if self.Execute  and  os.path.exists(targetdir) :
            shutil.rmtree( targetdir )
        if self.Execute :
            os.makedirs( os.path.join(targetdir, 'var', 'run') )
        print 'Populating', targetdir, 'from', basedir
        if not self.Execute :
            rsync_flags = '-avn' if self.Verbose > 1 else '-an'
        elif self.Verbose :
            rsync_flags = '-av'
        else :
            rsync_flags = '-a'
        cmd = [ '/usr/bin/rsync', rsync_flags ] + \
              list(rules.Rules) + \
              [ basedir, targetdir ]
        self._Execute( cmd, basedir )

    def _ShowArchives( self ) :
        if self.Execute or True:
            archives = self._ArchivePath('*', None, self._args.timestamp)
            matches = glob.glob(archives)
            if len(matches) :
                cmd = ( '/usr/bin/ls', '-lh' ) + tuple(glob.glob(matches))
                subprocess.call( cmd )

    def _ListArchives( self ) :
        archives = self._ArchivePath('*', None, '*')
        cmd = ( '/usr/bin/ls', '-lh' ) + tuple(glob.glob(archives))
        subprocess.call( cmd )

    def _CleanArchives( self, verstring ) :
        regex = re.compile( r'(\d{6}_\d{6})' )
        timestamps = []
        archives = []
        for archive in glob.glob(self._ArchivePath('*', verstring, '*')) :
            m = regex.search( archive )
            assert m is not None
            if m.group(1) != self._args.timestamp :
                timestamps.append( m.group(1) )
        for timestamp in timestamps :
            for archive in glob.glob(self._ArchivePath('*', None, timestamp)) :
                archives.append(archive)
        if self.Verbose and len(archives):
            print "Cleaning archives:", archives
        if self.Execute :
            for archive in archives :
                os.remove( archive )

    def _DetectGccVersion( self ) :
        cmd = ( 'gcc', '--version' )
        output = subprocess.check_output( cmd )
        try :
            match = re.search( r' (\d+\.\d+)\.\d+', output )
            if match is None :
                raise DetectionError("Unable to detect gcc version!")
            return match.group(1)
        except OSError as e :
            raise DetectionError("Unable to detect gcc version:"+str(e))

    def _DetectIronBeeVersion( self ) :
        if self._args.ib_version is None :
            libdir = os.environ['IB_LIBDIR']
            path = ibversion.IbVersionReader.FindFile( libdir )
            if path is None :
                raise DetectionError('Unable to find library file in "'+libdir+'"')
            vreader = ibversion.IbVersionReader( )
            return vreader.GetAutoVersion( path )
        else :
            return ibversion( self._args.ib_version )

    def _DetectGitBranch( self ) :
        if self._args.branch is not None :
            return self._args.branch
        else :
            repo = git.Repo( os.environ['IB_ROOT'])
            return repo.active_branch

    def _DetectStuff( self ) :
        try :
            self._arch = self._args.arch
            self._gccver = self._DetectGccVersion( )
            self._ibver = self._DetectIronBeeVersion( )
            self._branch = self._DetectGitBranch( )
            base = "{:s}-{:s}-{:s}".format(self._branch, self._ibver, self._args.timestamp)
            self._archive_dir = os.path.join(self._args.builds, base)
            if not self.Quiet :
                print 'Archives will be stored in "'+self._archive_dir
        except DetectionError as e:
            print >>sys.stderr, "Auto detection failed: ", e
            sys.exit(1)

    def _CreateBuildArchive( self ) :
        self._CreateArchive( 'build', verstring, self._args.build_root, ('gcc', install) )

    def _CreateLocalArchive( self ) :
        tmp = os.path.join(os.environ['QLYS_TMP'], 'qualys')
        rules = _RuleSet( 'rsync',
                          (
                              _IncludeRule('opt/trafficserver-'os.environ['ATS_VERSION']),
                              _ExcludeRule('opt/*'),
                              _ExcludeRule('etc/trafficserver/*'),
                              _ExcludeRule('**.release'),
                              _ExcludeRule('etc/ironbee/*'),
                              _ExcludeRule('**nginx'),
                              _ExcludeRule('.git'),
                              _ExcludeRule('*.log'),
                              _ExcludeRule('*.blog'),
                              _ExcludeRule('log/httpd/*'),
                              _ExcludeRule('*.lock'),
                              _ExcludeRule('*.meta'),
                              _ExcludeRule('data'),
                              _ExcludeRule('**/core'),
                              _ExcludeRule('crashes/*'),
                              _ExcludeRule('tmp/*'),
                              _ExcludeRule('*.db'),
                          )
                      )
        self._PopulateLocal( os.environ['QLYS_LOCAL'], tmp, rules)
        self._CreateArchive( 'local', None, tmp, ('.',) )

    def _CreateEtcArchive( self ) :
        self._CreateArchive( 'etc.in', None, os.environ['QLYS_DEVEL'], ('etc.in',),
                             _RuleSet( 'tar',
                                       (
                                           _ExcludeRule('*/trafficserver/release'),
                                           _ExcludeRule('*/trafficserver/'),
                                           _ExcludeRule('**/tmp'),
                                           _ExcludeRule('**/nginx'),
                                           _ExcludeRule('**/data'),
                                           _ExcludeRule('**/.git'),
                                           _ExcludeRule('**/*~'),
                                       )
                                   )

    def Main( self ) :
        self._ParseCmdline( )
        if self._args.list :
            self._ListArchives( )
            sys.exit( 0 )
        self._DetectStuff( )
        self._CreateBuildArchive( )
        self._CreateEtcArchive( )
        )
        if self._args.clean :
            self._CleanArchives( verstring )
        if not self.Quiet :
            self._ShowArchives( )

main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
