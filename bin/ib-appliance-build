#! /usr/bin/env python
###########################################################################
##
## Copyright(c) 2014 by Nick LeRoy, 310 Jones Ave, Fort Atkinson, WI
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
###########################################################################
import re
import os
import sys
import shutil
import subprocess
import argparse
import time
import glob
import ibversion

class _BaseRule( object ) :
    def __init__( self, _type, pattern ) :
        assert type(_type) == str
        assert type(pattern) == str
        assert _type in ( 'include', 'exclude' )
        self._type = _type
        self._pattern = pattern
    def __str__( self ) :
        return '--'+self._type+'='+self._pattern

class _IncludeRule( _BaseRule ) :
    def __init__( self, pattern ) :
        _BaseRule.__init__( self, 'include', pattern )

class _ExcludeRule( _BaseRule ) :
    def __init__( self, pattern ) :
        _BaseRule.__init__( self, 'exclude', pattern )

class _RuleSet( object ) :
    def __init__( self, name=None, rules=None ) :
        assert name is None or type(name) == str
        assert rules is None or type(rules) in (list, tuple)
        self._rules = []
        if rules is not None :
            self.AddRules( rules )

    def AddRules( self, rules ):
        assert type(rules) in (list, tuple)
        for rule in rules :
            self.AddRule( rule )

    def AddRule( self, rule ) :
        assert isinstance(rule, _BaseRule)
        self._rules.append(rule)

    def GetRules( self ) :
        return tuple( [ str(rule) for rule in self._rules ] )
    Rules = property( GetRules )
    

class _Main( object ) :
    def __init__( self ) :
        self._parser = argparse.ArgumentParser(
            description="Program to build an archive for appliances",
            prog="ib-appliance-build" )

        self._parser.add_argument( "--timestamp",
                                   action="store", dest="timestamp",
                                   default=time.strftime('%y%m%d_%H%M%S'),
                                   help="Specify timestamp <yymmdd_hhmmss>" )
        self._parser.add_argument( "--data-directory", "-d",
                                   action="store", dest="directory", default="/home/ironbee/data",
                                   help="Specify alternate directory </home/ironbee/data>" )
        self._parser.add_argument( "--arch",
                                   action="store", dest="arch", default=os.environ['SYS_ARCH'],
                                   help="Specify architector to use <"+os.environ['SYS_ARCH']+">" )
        self._parser.add_argument( "--build-path",
                                   action="store", dest="build_path", default="/build/qualys",
                                   help="Specify alternate directory </build/qualys>" )

        self._parser.add_argument( "--list",
                                   action="store_true", dest="list", default=False,
                                   help="List archives <default=no>" )

        self._parser.add_argument( "--ib-version",
                                   action="store", dest="ib_version", default=None,
                                   help="Specify IronBee version to use <auto>" )
        
        self._parser.add_argument( "--gcc-version",
                                   action="store", dest="gcc_version", default=None,
                                   help="Specify GCC version to use <auto>" )

        self._parser.set_defaults( clean=False )
        self._parser.add_argument( "--clean", "-c",
                                   action="store_true", dest="clean",
                                   help="Cleanup old archives <default=no>" )
        self._parser.add_argument( "--no-clean",
                                   action="store_false", dest="clean",
                                   help="Disable cleanup of old archives" )

        self._parser.add_argument( "--execute",
                                   action="store_true", dest="execute", default=True,
                                   help="Enable execution <default=yes>" )
        self._parser.add_argument( "-n", "--no-execute",
                                   action="store_false", dest="execute",
                                   help="Disable execution (for test/debug) <Default=execute>" )
        self._parser.add_argument( "-v", "--verbose",
                                   action="count", dest="verbose", default=0,
                                   help="Increment verbosity level" )
        self._parser.add_argument( "-q", "--quiet",
                                   action="store_true", dest="quiet", default=False,
                                   help="be vewwy quiet (I'm hunting wabbits) <default=no-quiet>" )

    def _ParseCmdline( self ) :
        self._args = self._parser.parse_args()
        if not self.Execute  and  self.Verbose == 0  and  not self.Quiet :
            self._verbose = 1

    Execute = property( lambda self : self._args.execute )
    Verbose = property( lambda self : self._args.verbose )
    Quiet   = property( lambda self : self._args.quiet )

    def _ArchivePath( self, name, name2, timestamp ) :
        if name2 is None :
            archive_name = '%s-%s-%s.tar.gz' % ( name, self._args.arch, timestamp )
        else :
            archive_name = '%s-ib_%s-%s-%s.tar.gz' % ( name, name2, self._args.arch, timestamp )
        return os.path.join( self._args.directory, archive_name )

    def _Execute( self, cmd, cwd=None ) :
        if not self.Quiet :
            if cwd is None :
                print 'Executing', cmd
            else :
                print 'Executing', cmd, 'from', cwd
        if self.Execute :
            subprocess.call( cmd, cwd=cwd )

    def _CreateArchive( self, name, name2, directory, targets, rules=None ) :
        if rules is None :
            rules = _RuleSet( )
        archive = self._ArchivePath(name, name2, self._args.timestamp)
        print 'Creating', name, 'archive', archive
        tar_cmd = 'cvfj' if self.Verbose else 'cfj'
        cmd = [ "/bin/tar", tar_cmd, archive ] + list(targets) + list(rules.Rules)
        self._Execute( cmd, directory )

    def _PopulateLocal( self, basedir, targetdir, rules ) :
        if self.Execute  and  os.path.exists(targetdir) :
            shutil.rmtree( targetdir )
        if self.Execute :
            os.makedirs( os.path.join(targetdir, 'var', 'run') )
        print 'Populating', targetdir, 'from', basedir
        if not self.Execute :
            rsync_flags = '-avn' if self.Verbose > 1 else '-an'
        elif self.Verbose :
            rsync_flags = '-av'
        else :
            rsync_flags = '-a'
        cmd = [ '/usr/bin/rsync', rsync_flags ] + \
              list(rules.Rules) + \
              [ basedir, targetdir ]
        self._Execute( cmd, basedir )

    def _ShowArchives( self ) :
        if self.Execute or True:
            archives = self._ArchivePath('*', None, self._args.timestamp)
            print archives, glob.glob(archives)
            cmd = ( '/usr/bin/ls', '-lh' ) + tuple(glob.glob(archives))
            subprocess.call( cmd )

    def _ListArchives( self ) :
        archives = self._ArchivePath('*', None, '*')
        print archives
        cmd = ( '/usr/bin/ls', '-lh' ) + tuple(glob.glob(archives))
        subprocess.call( cmd )

    def _RemoveOldArchives( self ) :
        archives = []
        for archive in glob.glob(self._ArchivePath('*', None, '*')) :
            if self._args.timestamp not in archive :
                archives.append( archive )
        if self.Verbose :
            print "Removing old archives", archives
        if self.Execute :
            for archive in archives :
                os.remove( archive )

    def _DetectGccVersion( self ) :
        cmd = ( 'gcc', '--version' )
        output = subprocess.check_output( cmd )
        try :
            match = re.search( r' (\d+\.\d+)\.\d+', output )
            if match is None :
                print >> sys.stderr, "Unable to detect gcc version!"
                sys.exit( 1 )
            return match.group(1)
        except OSError as e :
            print >> sys.stderr, "Unable to detect gcc version:", e
            sys.exit( 1 )

    def _DetectIronBeeVersion( self ) :
        libdir = os.environ['IB_LIBDIR']
        path = ibversion.IbVersionReader.FindFile( libdir )
        if path is None :
            self._parser.error( 'Unable to find library file in "'+libdir+'"' )
        vreader = ibversion.IbVersionReader( )
        version = vreader.GetAutoVersion( path )
        if version is None :
            print >> sys.stderr, "Unable to detect IronBee version!"
            sys.exit(1)
        print version, version.Major, version.Minor, version.Release
        return '%s.%s.%s' % (version.Major, version.Minor, version.Release)

    def Main( self ) :
        self._ParseCmdline( )
        if self._args.list :
            self._ListArchives( )
            sys.exit( 0 )
        if self._args.gcc_version is None :
            self._args.gcc_version = self._DetectGccVersion( )
        gcc = 'gcc-'+self._args.gcc_version
        if self._args.ib_version is None :
            self._args.ib_version = self._DetectIronBeeVersion( )
        install = os.path.join(gcc, 'install')
        if not self.Quiet :
            print 'Archives will be named "'+self._ArchivePath('<name>', None, self._args.timestamp)+'"'
        self._CreateArchive( 'build', self._args.ib_version, self._args.build_path, ('gcc', install) )
        self._PopulateLocal( '/local/qualys/',
                             '/local/qualys/tmp/qualys',
                             _RuleSet( 'rsync',
                                       (
                                           _IncludeRule('opt/trafficserver-'+os.environ['ATS_VERSION']),
                                           _ExcludeRule('opt/*'),
                                           _ExcludeRule('etc/trafficserver/*'),
                                           _ExcludeRule('**.release'),
                                           _ExcludeRule('etc/ironbee/*'),
                                           _ExcludeRule('**nginx'),
                                           _ExcludeRule('.git'),
                                           _ExcludeRule('*.log'),
                                           _ExcludeRule('*.blog'),
                                           _ExcludeRule('log/httpd/*'),
                                           _ExcludeRule('*.lock'),
                                           _ExcludeRule('*.meta'),
                                           _ExcludeRule('data'),
                                           _ExcludeRule('**/core'),
                                           _ExcludeRule('crashes/*'),
                                           _ExcludeRule('tmp/*'),
                                           _ExcludeRule('*.db'),
                                       )
                                   )
        )
        self._CreateArchive( 'local', None, '/local/qualys/tmp/qualys', ('.',) )
        self._CreateArchive( 'etc.in', None,
                             os.environ['QLYS_DEVEL'],
                             ('etc.in',),
                             _RuleSet( 'tar',
                                       (
                                           _ExcludeRule('*/trafficserver/release'),
                                           _ExcludeRule('*/trafficserver/'),
                                           _ExcludeRule('**/tmp'),
                                           _ExcludeRule('**/nginx'),
                                           _ExcludeRule('**/data'),
                                           _ExcludeRule('**/.git'),
                                           _ExcludeRule('**/*~'),
                                       ) 
                                   )
        )
        if self._args.clean :
            self._RemoveOldArchives( )
        if not self.Quiet :
            self._ShowArchives( )

main = _Main( )
main.Main( )

### Local Variables: ***
### py-indent-offset:4 ***
### python-indent:4 ***
### python-continuation-offset:4 ***
### tab-width:4  ***
### End: ***
